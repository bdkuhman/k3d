{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 What is k3d? \u00b6 k3d is a lightweight wrapper to run k3s (Rancher Lab\u2019s minimal Kubernetes distribution) in docker. k3d makes it very easy to create single- and multi-node k3s clusters in docker, e.g. for local development on Kubernetes. Note: k3d is a community-driven project but it\u2019s not an official Rancher (SUSE) product. Sponsoring : To spend any significant amount of time improving k3d, we rely on sponsorships: - GitHub Sponsors : - LiberaPay : - IssueHunt : https://issuehunt.io/r/k3d-io/k3d View a quick demo Learning \u00b6 k3d demo repository: iwilltry42/k3d-demo Featured use-cases include: hot-reloading of code when developing on k3d (Python Flask App) build-deploy-test cycle using Tilt full cluster lifecycle for simple and multi-server clusters Proof of Concept of using k3d as a service in Drone CI Rancher Meetup - May 2020 - Simplifying Your Cloud-Native Development Workflow With K3s, K3c and K3d (YouTube) Requirements \u00b6 docker to be able to use k3d at all Note: k3d v5.x.x requires at least Docker v20.10.5 (runc >= v1.0.0-rc93) to work properly (see #807 ) kubectl to interact with the Kubernetes cluster Releases \u00b6 Platform Stage Version Release Date Downloads so far GitHub Releases stable GitHub Releases latest Homebrew stable - - Chocolatey stable - - Installation \u00b6 You have several options there: Install Script \u00b6 Install current latest release \u00b6 wget: wget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash curl: curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash Install specific release \u00b6 Use the install script to grab a specific release (via TAG environment variable): wget: wget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | TAG = v5.0.0 bash curl: curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | TAG = v5.0.0 bash Other Installers \u00b6 Other Installation Methods :fontawesome-solid-beer: Homebrew (MacOS/Linux) : brew install k3d Note : The formula can be found in homebrew/homebrew-core and is mirrored to homebrew/linuxbrew-core AUR (Arch Linux User Repository) : yay -S rancher-k3d-bin Package rancher-k3d-bin Download GitHub Release Grab a release binary from the release tab and install it yourself Chocolatey (Windows) : choco install k3d Note : package source can be found in erwinkersten/chocolatey-packages arkade : arkade get k3d asdf : asdf plugin-add k3d && asdf install k3d latest Note : asdf plugin-add k3d , then asdf install k3d <tag> with <tag> = latest or 5.x.x for a specific version (maintained by spencergilbert/asdf-k3d ) Others install via go: go install github.com/k3d-io/k3d/v5@latest ( Note : this will give you unreleased/bleeding-edge changes) Quick Start \u00b6 Create a cluster named mycluster with just a single server node: k3d cluster create mycluster Use the new cluster with kubectl , e.g.: kubectl get nodes Getting the cluster\u2019s kubeconfig (included in k3d cluster create ) Get the new cluster\u2019s connection details merged into your default kubeconfig (usually specified using the KUBECONFIG environment variable or the default path $HOME /.kube/config ) and directly switch to the new context: k3d kubeconfig merge mycluster --kubeconfig-switch-context Connect \u00b6 Join the Rancher community on slack via slack.rancher.io Go to rancher-users.slack.com and join our channel #k3d Start chatting Related Projects \u00b6 vscode-k3d : VSCode Extension to handle k3d clusters from within VSCode k3x : a graphics interface (for Linux) to k3d. AbsaOSS/k3d-action : fully customizable GitHub Action to run lightweight Kubernetes clusters. AutoK3s : a lightweight tool to help run K3s everywhere including k3d provider. nolar/setup-k3d-k3s : setup K3d/K3s for GitHub Actions.","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#what-is-k3d","text":"k3d is a lightweight wrapper to run k3s (Rancher Lab\u2019s minimal Kubernetes distribution) in docker. k3d makes it very easy to create single- and multi-node k3s clusters in docker, e.g. for local development on Kubernetes. Note: k3d is a community-driven project but it\u2019s not an official Rancher (SUSE) product. Sponsoring : To spend any significant amount of time improving k3d, we rely on sponsorships: - GitHub Sponsors : - LiberaPay : - IssueHunt : https://issuehunt.io/r/k3d-io/k3d View a quick demo","title":"What is k3d?"},{"location":"#learning","text":"k3d demo repository: iwilltry42/k3d-demo Featured use-cases include: hot-reloading of code when developing on k3d (Python Flask App) build-deploy-test cycle using Tilt full cluster lifecycle for simple and multi-server clusters Proof of Concept of using k3d as a service in Drone CI Rancher Meetup - May 2020 - Simplifying Your Cloud-Native Development Workflow With K3s, K3c and K3d (YouTube)","title":"Learning"},{"location":"#requirements","text":"docker to be able to use k3d at all Note: k3d v5.x.x requires at least Docker v20.10.5 (runc >= v1.0.0-rc93) to work properly (see #807 ) kubectl to interact with the Kubernetes cluster","title":"Requirements"},{"location":"#releases","text":"Platform Stage Version Release Date Downloads so far GitHub Releases stable GitHub Releases latest Homebrew stable - - Chocolatey stable - -","title":"Releases"},{"location":"#installation","text":"You have several options there:","title":"Installation"},{"location":"#install-script","text":"","title":" Install Script"},{"location":"#install-current-latest-release","text":"wget: wget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash curl: curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash","title":"Install current latest release"},{"location":"#install-specific-release","text":"Use the install script to grab a specific release (via TAG environment variable): wget: wget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | TAG = v5.0.0 bash curl: curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | TAG = v5.0.0 bash","title":"Install specific release"},{"location":"#other-installers","text":"Other Installation Methods :fontawesome-solid-beer: Homebrew (MacOS/Linux) : brew install k3d Note : The formula can be found in homebrew/homebrew-core and is mirrored to homebrew/linuxbrew-core AUR (Arch Linux User Repository) : yay -S rancher-k3d-bin Package rancher-k3d-bin Download GitHub Release Grab a release binary from the release tab and install it yourself Chocolatey (Windows) : choco install k3d Note : package source can be found in erwinkersten/chocolatey-packages arkade : arkade get k3d asdf : asdf plugin-add k3d && asdf install k3d latest Note : asdf plugin-add k3d , then asdf install k3d <tag> with <tag> = latest or 5.x.x for a specific version (maintained by spencergilbert/asdf-k3d ) Others install via go: go install github.com/k3d-io/k3d/v5@latest ( Note : this will give you unreleased/bleeding-edge changes)","title":"Other Installers"},{"location":"#quick-start","text":"Create a cluster named mycluster with just a single server node: k3d cluster create mycluster Use the new cluster with kubectl , e.g.: kubectl get nodes Getting the cluster\u2019s kubeconfig (included in k3d cluster create ) Get the new cluster\u2019s connection details merged into your default kubeconfig (usually specified using the KUBECONFIG environment variable or the default path $HOME /.kube/config ) and directly switch to the new context: k3d kubeconfig merge mycluster --kubeconfig-switch-context","title":"Quick Start"},{"location":"#connect","text":"Join the Rancher community on slack via slack.rancher.io Go to rancher-users.slack.com and join our channel #k3d Start chatting","title":"Connect"},{"location":"#related-projects","text":"vscode-k3d : VSCode Extension to handle k3d clusters from within VSCode k3x : a graphics interface (for Linux) to k3d. AbsaOSS/k3d-action : fully customizable GitHub Action to run lightweight Kubernetes clusters. AutoK3s : a lightweight tool to help run K3s everywhere including k3d provider. nolar/setup-k3d-k3s : setup K3d/K3s for GitHub Actions.","title":"Related Projects"},{"location":"design/concepts/","text":"Concepts \u00b6 Nodefilters \u00b6 About \u00b6 Nodefilters are a concept in k3d to specify which nodes of a newly created cluster a condition or setting should apply to. Syntax \u00b6 The overall syntax is @<group>:<subset>[:<suffix] . @ denotes the start of a nodefilter in a k3d flag value <group> denotes the node group you want to filter in one of server , servers , agent , agents , loadbalancer , all note, that all also includes the cluster-external server loadbalancer ( k3d-proxy container) <subset> denotes the subset of the chosen group you want to apply the flag to wildcard * : all nodes in that group index, e.g. 0 : only the first node of that group list, e.g. 1,3,5 : nodes 1, 3 and 5 of that group range, e.g. 2-4 : nodes 2 to 4 of that group <suffix> (optional) can hold some flag specific configuration e.g. for the --port flag this could be direct or proxy (default) to configure the way of exposing ports Example \u00b6 Problem: You want to have Nginx as your ingress controller, but by default, K3s deploys Traefik. Solution: Disabling the default Traefik deployment using K3s\u2019 --disable=traefik flag. Note: It\u2019s enough to do this on the first (initializing) server node. How-To: k3d cluster create notraefik --k3s-arg=\"--disable=traefik@server:0\" Looking at --k3s-arg=\"--disable=traefik@server:0\" , everything after the @ sign is part of the nodefilter. server is the node group: server nodes after the : follows the subset, which in this case is the index 0 : the first server node to be created ( k3d-notraefik-server-0 )","title":"Concepts"},{"location":"design/concepts/#concepts","text":"","title":"Concepts"},{"location":"design/concepts/#nodefilters","text":"","title":"Nodefilters"},{"location":"design/concepts/#about","text":"Nodefilters are a concept in k3d to specify which nodes of a newly created cluster a condition or setting should apply to.","title":"About"},{"location":"design/concepts/#syntax","text":"The overall syntax is @<group>:<subset>[:<suffix] . @ denotes the start of a nodefilter in a k3d flag value <group> denotes the node group you want to filter in one of server , servers , agent , agents , loadbalancer , all note, that all also includes the cluster-external server loadbalancer ( k3d-proxy container) <subset> denotes the subset of the chosen group you want to apply the flag to wildcard * : all nodes in that group index, e.g. 0 : only the first node of that group list, e.g. 1,3,5 : nodes 1, 3 and 5 of that group range, e.g. 2-4 : nodes 2 to 4 of that group <suffix> (optional) can hold some flag specific configuration e.g. for the --port flag this could be direct or proxy (default) to configure the way of exposing ports","title":"Syntax"},{"location":"design/concepts/#example","text":"Problem: You want to have Nginx as your ingress controller, but by default, K3s deploys Traefik. Solution: Disabling the default Traefik deployment using K3s\u2019 --disable=traefik flag. Note: It\u2019s enough to do this on the first (initializing) server node. How-To: k3d cluster create notraefik --k3s-arg=\"--disable=traefik@server:0\" Looking at --k3s-arg=\"--disable=traefik@server:0\" , everything after the @ sign is part of the nodefilter. server is the node group: server nodes after the : follows the subset, which in this case is the index 0 : the first server node to be created ( k3d-notraefik-server-0 )","title":"Example"},{"location":"design/defaults/","text":"Defaults \u00b6 k3d reserved settings \u00b6 When you create a K3s cluster in Docker using k3d, we make use of some K3s configuration options, making them \u201creserved\u201d for k3d. This means, that overriding those options with your own may break the cluster setup. Environment Variables \u00b6 The following K3s environment variables are used to configure the cluster: Variable K3d Default Configurable? K3S_URL https://$CLUSTERNAME-server-0:6443 no K3S_TOKEN random yes ( --token ) K3S_KUBECONFIG_OUTPUT /output/kubeconfig.yaml no k3d Loadbalancer \u00b6 By default, k3d creates an Nginx loadbalancer alongside the clusters it creates to handle the port-forwarding. The loadbalancer can partly be configured using k3d-defined settings. Nginx setting k3d default k3d setting proxy_timeout (default for all server stanzas) 600 (s) settings.defaultProxyTimeout worker_connections 1024 settings.workerConnections Overrides \u00b6 Example via CLI: k3d cluster create --lb-config-override settings.defaultProxyTimeout=900 Example via Config File: # ... truncated ... k3d : loadbalancer : configOverrides : - settings.workerConnections=2048 Multiple server nodes \u00b6 by default, when --server > 1 and no --datastore-x option is set, the first server node (server-0) will be the initializing server node the initializing server node will have the --cluster-init flag appended all other server nodes will refer to the initializing server node via --server https://<init-node>:6443 API-Ports \u00b6 by default, we expose the API-Port ( 6443 ) by forwarding traffic from the default server loadbalancer (nginx container) to the server node(s) port 6443 of the loadbalancer is then mapped to a specific ( --api-port flag) or a random (default) port on the host system Kubeconfig \u00b6 if --kubeconfig-update-default is set, we use the default loading rules to get the default kubeconfig: First: kubeconfig specified via the KUBECONFIG environment variable (error out if multiple are specified) Second: default kubeconfig in home directory (e.g. $HOME/.kube/config ) Networking \u00b6 by default, k3d creates a new (docker) network for every cluster","title":"Defaults"},{"location":"design/defaults/#defaults","text":"","title":"Defaults"},{"location":"design/defaults/#k3d-reserved-settings","text":"When you create a K3s cluster in Docker using k3d, we make use of some K3s configuration options, making them \u201creserved\u201d for k3d. This means, that overriding those options with your own may break the cluster setup.","title":"k3d reserved settings"},{"location":"design/defaults/#environment-variables","text":"The following K3s environment variables are used to configure the cluster: Variable K3d Default Configurable? K3S_URL https://$CLUSTERNAME-server-0:6443 no K3S_TOKEN random yes ( --token ) K3S_KUBECONFIG_OUTPUT /output/kubeconfig.yaml no","title":"Environment Variables"},{"location":"design/defaults/#k3d-loadbalancer","text":"By default, k3d creates an Nginx loadbalancer alongside the clusters it creates to handle the port-forwarding. The loadbalancer can partly be configured using k3d-defined settings. Nginx setting k3d default k3d setting proxy_timeout (default for all server stanzas) 600 (s) settings.defaultProxyTimeout worker_connections 1024 settings.workerConnections","title":"k3d Loadbalancer"},{"location":"design/defaults/#overrides","text":"Example via CLI: k3d cluster create --lb-config-override settings.defaultProxyTimeout=900 Example via Config File: # ... truncated ... k3d : loadbalancer : configOverrides : - settings.workerConnections=2048","title":"Overrides"},{"location":"design/defaults/#multiple-server-nodes","text":"by default, when --server > 1 and no --datastore-x option is set, the first server node (server-0) will be the initializing server node the initializing server node will have the --cluster-init flag appended all other server nodes will refer to the initializing server node via --server https://<init-node>:6443","title":"Multiple server nodes"},{"location":"design/defaults/#api-ports","text":"by default, we expose the API-Port ( 6443 ) by forwarding traffic from the default server loadbalancer (nginx container) to the server node(s) port 6443 of the loadbalancer is then mapped to a specific ( --api-port flag) or a random (default) port on the host system","title":"API-Ports"},{"location":"design/defaults/#kubeconfig","text":"if --kubeconfig-update-default is set, we use the default loading rules to get the default kubeconfig: First: kubeconfig specified via the KUBECONFIG environment variable (error out if multiple are specified) Second: default kubeconfig in home directory (e.g. $HOME/.kube/config )","title":"Kubeconfig"},{"location":"design/defaults/#networking","text":"by default, k3d creates a new (docker) network for every cluster","title":"Networking"},{"location":"design/networking/","text":"Networking \u00b6 Related issues: k3d-io/k3d #220 Introduction \u00b6 By default, k3d creates a new (docker) network for every new cluster. Using the --network STRING flag upon creation to connect to an existing network. Existing networks won\u2019t be managed by k3d together with the cluster lifecycle. Connecting to docker \u201cinternal\u201d/pre-defined networks \u00b6 host network \u00b6 When using the --network flag to connect to the host network (i.e. k3d cluster create --network host ), you won\u2019t be able to create more than one server node . An edge case would be one server node (with agent disabled) and one agent node. bridge network \u00b6 By default, every network that k3d creates is working in bridge mode. But when you try to use --network bridge to connect to docker\u2019s internal bridge network, you may run into issues with grabbing certificates from the API-Server. Single-Node clusters should work though. none \u201cnetwork\u201d \u00b6 Well.. this doesn\u2019t really make sense for k3d anyway \u00af\\_(\u30c4)_/\u00af","title":"Networking"},{"location":"design/networking/#networking","text":"Related issues: k3d-io/k3d #220","title":"Networking"},{"location":"design/networking/#introduction","text":"By default, k3d creates a new (docker) network for every new cluster. Using the --network STRING flag upon creation to connect to an existing network. Existing networks won\u2019t be managed by k3d together with the cluster lifecycle.","title":"Introduction"},{"location":"design/networking/#connecting-to-docker-internalpre-defined-networks","text":"","title":"Connecting to docker \"internal\"/pre-defined networks"},{"location":"design/networking/#host-network","text":"When using the --network flag to connect to the host network (i.e. k3d cluster create --network host ), you won\u2019t be able to create more than one server node . An edge case would be one server node (with agent disabled) and one agent node.","title":"host network"},{"location":"design/networking/#bridge-network","text":"By default, every network that k3d creates is working in bridge mode. But when you try to use --network bridge to connect to docker\u2019s internal bridge network, you may run into issues with grabbing certificates from the API-Server. Single-Node clusters should work though.","title":"bridge network"},{"location":"design/networking/#none-network","text":"Well.. this doesn\u2019t really make sense for k3d anyway \u00af\\_(\u30c4)_/\u00af","title":"none \"network\""},{"location":"design/project/","text":"Project Overview \u00b6 About This Page \u00b6 On this page we\u2019ll try to give an overview of all the moving bits and pieces in k3d to ease contributions to the project. Directory Overview \u00b6 .github/ templates for issues and pull requests GitHub Action workflow definitions cmd/ everything related to the actual k3d CLI, like the whole command tree, config initialization, argument parsing, etc. docgen/ sub-module used to auto-generate the documentation for the CLI commands, which ends up in docs/usage/commands/ docs/ all the resources used to build k3d.io using mkdocs pkg/ the place where the magic happens.. here you find all the main logic of k3d all function calls within cmd/ that do non-trivial things are imported from here this (or rather sub-packages) is what other projects would import as a module to work with k3d without using the CLI proxy/ configuration to build the k3d-io/k3d-proxy container image which is used as a loadbalancer/proxy in front of (almost) every k3d cluster this is basically just a combination of NGINX with confd and some k3d-specific configuration details tests/ a set of bash scripts used for end-to-end (E2E) tests of k3d mostly used for all the functionality of the k3d CLI which cannot be tested using Go unit tests tools/ sub-module used to build the k3d-io/k3d-tools container image which supports some k3d functionality like k3d image import vendor/ result of go mod vendor , which contains all dependencies of k3d version/ package used to code k3d/k3s versions into releases this is where go build injects the version tags when building k3d that\u2019s the output you see when issuing k3d version Packages Overview \u00b6 pkg/ actions/ hook actions describing actions (commands, etc.) that run at specific stages of the node/cluster lifecycle e.g. writing configuration files to the container filesystem just before the node (container) starts client/ all the top level functionality to work with k3d primitives create/retrieve/update/delete/start/stop clusters, nodes, registries, etc. managed by k3d config/ everything related to the k3d configuration (files), like SimpleConfig and ClusterConfig runtimes/ interface and implementations of runtimes that power k3d (currently, that\u2019s only Docker) functions in client/ eventually call runtime functions to \u201cmaterialize\u201d nodes and clusters tools/ functions eventually calling the k3d-tools container (see tools/ in the repo root) types/ definition of all k3d primitives and many other details and defaults e.g. contains the definition of a Node or a Cluster in k3d util/ some helper functions e.g. for string manipulation/generation, regexp or other re-usable usages Anatomy of a Cluster \u00b6 By default, every k3d cluster consists of at least 2 containers (nodes): (optional, but default and strongly recommended) loadbalancer image: ghcr.io/k3d-io/k3d-proxy , built from proxy/ purpose: proxy and load balance requests from the outside (i.e. most of the times your local host) to the cluster by default, it e.g. proxies all the traffic for the Kubernetes API to port 6443 (default listening port of K3s) to all the server nodes in the cluster can be used for multiple port-mappings to one or more nodes in your cluster that way, port-mappings can also easily be added/removed after the cluster creation, as we can simply re-create the proxy without affecting cluster state (required, always present) primary server node image: rancher/k3s , built from github.com/k3s-io/k3s purpose: (initializing) server (formerly: master) node of the cluster runs the K3s executable (which runs containerd, the Kubernetes API Server, etcd/sqlite, etc.): k3s server in a multi-server setup, it initializes the cluster with an embedded etcd database (using the K3s --cluster-init flag) (optional) secondary server node(s) image: rancher/k3s , built from github.com/k3s-io/k3s (optional) agent node(s) image: rancher/k3s , built from github.com/k3s-io/k3s purpose: running the K3s agent process (kubelet, etc.): k3s agent Automation (CI) \u00b6 The k3d repository mainly leverages the following two CI systems: GitHub Actions 2 workflows in https://github.com/k3d-io/k3d/tree/main/.github/workflows to push the artifact to AUR (Arch Linux User Repository) logs/history can be seen in the Actions tab: https://github.com/k3d-io/k3d/actions static code analysis build tests docker builds + pushes render + push docs (pre-) release to GitHub Documentation \u00b6 The website k3d.io containing all the documentation for k3d is built using mkdocs , configured via the mkdocs.yml config file with all the content residing in the docs/ directory (Markdown). Use mkdocs serve in the repository root to build and serve the webpage locally. Some parts of the documentation are being auto-generated, like docs/usage/commands/ is auto-generated using Cobra\u2019s command docs generation functionality in docgen/ .","title":"Project Overview"},{"location":"design/project/#project-overview","text":"","title":"Project Overview"},{"location":"design/project/#about-this-page","text":"On this page we\u2019ll try to give an overview of all the moving bits and pieces in k3d to ease contributions to the project.","title":"About This Page"},{"location":"design/project/#directory-overview","text":".github/ templates for issues and pull requests GitHub Action workflow definitions cmd/ everything related to the actual k3d CLI, like the whole command tree, config initialization, argument parsing, etc. docgen/ sub-module used to auto-generate the documentation for the CLI commands, which ends up in docs/usage/commands/ docs/ all the resources used to build k3d.io using mkdocs pkg/ the place where the magic happens.. here you find all the main logic of k3d all function calls within cmd/ that do non-trivial things are imported from here this (or rather sub-packages) is what other projects would import as a module to work with k3d without using the CLI proxy/ configuration to build the k3d-io/k3d-proxy container image which is used as a loadbalancer/proxy in front of (almost) every k3d cluster this is basically just a combination of NGINX with confd and some k3d-specific configuration details tests/ a set of bash scripts used for end-to-end (E2E) tests of k3d mostly used for all the functionality of the k3d CLI which cannot be tested using Go unit tests tools/ sub-module used to build the k3d-io/k3d-tools container image which supports some k3d functionality like k3d image import vendor/ result of go mod vendor , which contains all dependencies of k3d version/ package used to code k3d/k3s versions into releases this is where go build injects the version tags when building k3d that\u2019s the output you see when issuing k3d version","title":"Directory Overview"},{"location":"design/project/#packages-overview","text":"pkg/ actions/ hook actions describing actions (commands, etc.) that run at specific stages of the node/cluster lifecycle e.g. writing configuration files to the container filesystem just before the node (container) starts client/ all the top level functionality to work with k3d primitives create/retrieve/update/delete/start/stop clusters, nodes, registries, etc. managed by k3d config/ everything related to the k3d configuration (files), like SimpleConfig and ClusterConfig runtimes/ interface and implementations of runtimes that power k3d (currently, that\u2019s only Docker) functions in client/ eventually call runtime functions to \u201cmaterialize\u201d nodes and clusters tools/ functions eventually calling the k3d-tools container (see tools/ in the repo root) types/ definition of all k3d primitives and many other details and defaults e.g. contains the definition of a Node or a Cluster in k3d util/ some helper functions e.g. for string manipulation/generation, regexp or other re-usable usages","title":"Packages Overview"},{"location":"design/project/#anatomy-of-a-cluster","text":"By default, every k3d cluster consists of at least 2 containers (nodes): (optional, but default and strongly recommended) loadbalancer image: ghcr.io/k3d-io/k3d-proxy , built from proxy/ purpose: proxy and load balance requests from the outside (i.e. most of the times your local host) to the cluster by default, it e.g. proxies all the traffic for the Kubernetes API to port 6443 (default listening port of K3s) to all the server nodes in the cluster can be used for multiple port-mappings to one or more nodes in your cluster that way, port-mappings can also easily be added/removed after the cluster creation, as we can simply re-create the proxy without affecting cluster state (required, always present) primary server node image: rancher/k3s , built from github.com/k3s-io/k3s purpose: (initializing) server (formerly: master) node of the cluster runs the K3s executable (which runs containerd, the Kubernetes API Server, etcd/sqlite, etc.): k3s server in a multi-server setup, it initializes the cluster with an embedded etcd database (using the K3s --cluster-init flag) (optional) secondary server node(s) image: rancher/k3s , built from github.com/k3s-io/k3s (optional) agent node(s) image: rancher/k3s , built from github.com/k3s-io/k3s purpose: running the K3s agent process (kubelet, etc.): k3s agent","title":"Anatomy of a Cluster"},{"location":"design/project/#automation-ci","text":"The k3d repository mainly leverages the following two CI systems: GitHub Actions 2 workflows in https://github.com/k3d-io/k3d/tree/main/.github/workflows to push the artifact to AUR (Arch Linux User Repository) logs/history can be seen in the Actions tab: https://github.com/k3d-io/k3d/actions static code analysis build tests docker builds + pushes render + push docs (pre-) release to GitHub","title":"Automation (CI)"},{"location":"design/project/#documentation","text":"The website k3d.io containing all the documentation for k3d is built using mkdocs , configured via the mkdocs.yml config file with all the content residing in the docs/ directory (Markdown). Use mkdocs serve in the repository root to build and serve the webpage locally. Some parts of the documentation are being auto-generated, like docs/usage/commands/ is auto-generated using Cobra\u2019s command docs generation functionality in docgen/ .","title":"Documentation"},{"location":"faq/compatibility/","text":"Compatibility \u00b6 With each release, we test if k3d works with specific versions of Docker and K3s, to ensure, that at least the most recent versions of Docker and the active releases (i.e. non-EOL release channels, similar to Kubernetes) work properly with it. The tests happen automatically in GitHub Actions. Some versions of Docker and K3s are expected to fail with specific versions of k3d due to e.g. incompatible dependencies or missing features. We test a full cluster lifecycle with different K3s channels , meaning that the following list refers to the current latest version released under the given channel. Releases \u00b6 v5.4.0 - 26.03.2022 \u00b6 Test Workflow: https://github.com/k3d-io/k3d/actions/runs/2044325827 Docker \u00b6 20.10.5 20.10.12 Expected to Fail with the following versions: <= 20.10.4 (due to runc, see https://github.com/k3d-io/k3d/issues/807 ) K3s \u00b6 Channel v1.23 Channel v1.22 Expected to Fail with the following versions: <= v1.18 (due to not included, but expected CoreDNS in K3s) v5.3.0 - 03.02.2022 \u00b6 Docker \u00b6 20.10.5 20.10.12 Expected to Fail with the following versions: <= 20.10.4 (due to runc, see https://github.com/k3d-io/k3d/issues/807 ) K3s \u00b6 Channel v1.23 Channel v1.22 Expected to Fail with the following versions: <= v1.18 (due to not included, but expected CoreDNS in K3s)","title":"Compatibility"},{"location":"faq/compatibility/#compatibility","text":"With each release, we test if k3d works with specific versions of Docker and K3s, to ensure, that at least the most recent versions of Docker and the active releases (i.e. non-EOL release channels, similar to Kubernetes) work properly with it. The tests happen automatically in GitHub Actions. Some versions of Docker and K3s are expected to fail with specific versions of k3d due to e.g. incompatible dependencies or missing features. We test a full cluster lifecycle with different K3s channels , meaning that the following list refers to the current latest version released under the given channel.","title":"Compatibility"},{"location":"faq/compatibility/#releases","text":"","title":"Releases"},{"location":"faq/compatibility/#v540-26032022","text":"Test Workflow: https://github.com/k3d-io/k3d/actions/runs/2044325827","title":"v5.4.0 - 26.03.2022"},{"location":"faq/compatibility/#docker","text":"20.10.5 20.10.12 Expected to Fail with the following versions: <= 20.10.4 (due to runc, see https://github.com/k3d-io/k3d/issues/807 )","title":"Docker"},{"location":"faq/compatibility/#k3s","text":"Channel v1.23 Channel v1.22 Expected to Fail with the following versions: <= v1.18 (due to not included, but expected CoreDNS in K3s)","title":"K3s"},{"location":"faq/compatibility/#v530-03022022","text":"","title":"v5.3.0 - 03.02.2022"},{"location":"faq/compatibility/#docker_1","text":"20.10.5 20.10.12 Expected to Fail with the following versions: <= 20.10.4 (due to runc, see https://github.com/k3d-io/k3d/issues/807 )","title":"Docker"},{"location":"faq/compatibility/#k3s_1","text":"Channel v1.23 Channel v1.22 Expected to Fail with the following versions: <= v1.18 (due to not included, but expected CoreDNS in K3s)","title":"K3s"},{"location":"faq/faq/","text":"FAQ \u00b6 Issues with BTRFS \u00b6 As @jaredallard pointed out , people running k3d on a system with btrfs , may need to mount /dev/mapper into the nodes for the setup to work. This will do: k3d cluster create CLUSTER_NAME -v /dev/mapper:/dev/mapper Issues with ZFS \u00b6 k3s currently has no support for ZFS and thus, creating multi-server setups (e.g. k3d cluster create multiserver --servers 3 ) fails, because the initializing server node (server flag --cluster-init ) errors out with the following log: starting kubernetes: preparing server: start cluster and https: raft_init () : io: create I/O capabilities probe file: posix_allocate: operation not supported on socket This issue can be worked around by providing docker with a different filesystem (that\u2019s also better for docker-in-docker stuff). A possible solution can be found here: https://github.com/rancher/k3s/issues/1688#issuecomment-619570374 Pods evicted due to lack of disk space \u00b6 Pods go to evicted state after doing X Related issues: #133 - Pods evicted due to NodeHasDiskPressure (collection of #119 and #130) Background: somehow docker runs out of space for the k3d node containers, which triggers a hard eviction in the kubelet Possible fix/workaround by @zer0def : use a docker storage driver which cleans up properly (e.g. overlay2) clean up or expand docker root filesystem change the kubelet\u2019s eviction thresholds upon cluster creation: k3d cluster create \\ --k3s-arg '--kubelet-arg=eviction-hard=imagefs.available<1%,nodefs.available<1%@agent:*' \\ --k3s-arg '--kubelet-arg=eviction-minimum-reclaim=imagefs.available=1%,nodefs.available=1%@agent:*' Restarting a multi-server cluster or the initializing server node fails \u00b6 What you do: You create a cluster with more than one server node and later, you either stop server-0 or stop/start the whole cluster What fails: After the restart, you cannot connect to the cluster anymore and kubectl will give you a lot of errors What causes this issue: it\u2019s a known issue with dqlite in k3s which doesn\u2019t allow the initializing server node to go down What\u2019s the solution: Hopefully, this will be solved by the planned replacement of dqlite with embedded etcd in k3s Related issues: #262 Passing additional arguments/flags to k3s (and on to e.g. the kube-apiserver) \u00b6 The Problem: Passing a feature flag to the Kubernetes API Server running inside k3s. Example: you want to enable the EphemeralContainers feature flag in Kubernetes Solution: k3d cluster create \\ --k3s-arg '--kube-apiserver-arg=feature-gates=EphemeralContainers=true@server:*' \\ --k3s-arg '--kube-scheduler-arg=feature-gates=EphemeralContainers=true@server:*' \\ --k3s-arg '--kubelet-arg=feature-gates=EphemeralContainers=true@agent:*' Note : Be aware of where the flags require dashes ( -- ) and where not. the k3s flag ( --kube-apiserver-arg ) has the dashes the kube-apiserver flag feature-gates doesn\u2019t have them (k3s adds them internally) Second example: k3d cluster create k3d-one \\ --k3s-arg \"--cluster-cidr=10.118.0.0/17@server:*\" \\ --k3s-arg \"--service-cidr=10.118.128.0/17@server:*\" \\ --k3s-arg \"--disable=servicelb@server:*\" \\ --k3s-arg \"--disable=traefik@server:*\" \\ --verbose Note : There are many ways to use the \" and ' quotes, just be aware, that sometimes shells also try to interpret/interpolate parts of the commands How to access services (like a database) running on my Docker Host Machine \u00b6 As of version v3.1.0, we\u2019re injecting the host.k3d.internal entry into the k3d containers (k3s nodes) and into the CoreDNS ConfigMap, enabling you to access your host system by referring to it as host.k3d.internal Running behind a corporate proxy \u00b6 Running k3d behind a corporate proxy can lead to some issues with k3d that have already been reported in more than one issue. Some can be fixed by passing the HTTP_PROXY environment variables to k3d, some have to be fixed in docker\u2019s daemon.json file and some are as easy as adding a volume mount. Pods fail to start: x509: certificate signed by unknown authority \u00b6 Example Error Message: Failed to create pod sandbox: rpc error: code = Unknown desc = failed to get sandbox image \"docker.io/rancher/pause:3.1\" : failed to pull image \"docker.io/rancher/pause:3.1\" : failed to pull and unpack image \"docker.io/rancher/pause:3.1\" : failed to resolve reference \"docker.io/rancher/pause:3.1\" : failed to do request: Head https://registry-1.docker.io/v2/rancher/pause/manifests/3.1: x509: certificate signed by unknown authority Problem: inside the container, the certificate of the corporate proxy cannot be validated Possible Solution: Mounting the CA Certificate from your host into the node containers at start time via k3d cluster create --volume /path/to/your/certs.crt:/etc/ssl/certs/yourcert.crt Issue: k3d-io/k3d#535 Spurious PID entries in /proc after deleting k3d cluster with shared mounts \u00b6 When you perform cluster create and deletion operations multiple times with same cluster name and shared volume mounts , it was observed that grep k3d /proc/*/mountinfo shows many spurious entries Problem: Due to above, at times you\u2019ll see no space left on device: unknown when a pod is scheduled to the nodes If you observe anything of above sort you can check for inaccessible file systems and unmount them by using below command (note: please remove xargs umount -l and check for the diff o/p first) diff <(df -ha | grep pods | awk '{print $NF}') <(df -h | grep pods | awk '{print $NF}') | awk '{print $2}' | xargs umount -l As per the conversation on k3d-io/k3d#594 above issue wasn\u2019t reported/known earlier and so there are high chances that it\u2019s not universal. [SOLVED] Nodes fail to start or get stuck in NotReady state with log nf_conntrack_max: permission denied \u00b6 Problem \u00b6 When: This happens when running k3d on a Linux system with a kernel version >= 5.12.2 (and others like >= 5.11.19) when creating a new cluster the node(s) stop or get stuck with a log line like this: <TIMESTAMP> F0516 05:05:31.782902 7 server.go:495] open /proc/sys/net/netfilter/nf_conntrack_max: permission denied Why: The issue was introduced by a change in the Linux kernel ( Changelog 5.12.2 : Commit ), that changed the netfilter_conntrack behavior in a way that kube-proxy is not able to set the nf_conntrack_max value anymore Workaround \u00b6 Workaround: as a workaround, we can tell kube-proxy to not even try to set this value: k3d cluster create \\ --k3s-arg \"--kube-proxy-arg=conntrack-max-per-core=0@server:*\" \\ --k3s-arg \"--kube-proxy-arg=conntrack-max-per-core=0@agent:*\" \\ --image rancher/k3s:v1.20.6-k3s Fix \u00b6 Note : k3d v4.4.5 already uses rancher/k3s:v1.21.1-k3s1 as the new default k3s image, so no workarounds needed there! This is going to be fixed \u201cupstream\u201d in k3s itself in rancher/k3s#3337 and backported to k3s versions as low as v1.18. The fix was released and backported in k3s, so you don\u2019t need to use the workaround when using one of the following k3s versions (or later ones) v1.18.19-k3s1 ( rancher/k3s#3344 ) v1.19.11-k3s1 ( rancher/k3s#3343 ) v1.20.7-k3s1 ( rancher/k3s#3342 ) v1.21.1-k3s1 ( rancher/k3s#3341 )) Issue Reference: rancher/k3s#607 DockerHub Pull Rate Limit \u00b6 Problem \u00b6 You\u2019re deploying something to the cluster using an image from DockerHub and the image fails to be pulled, with a 429 response code and a message saying You have reached your pull rate limit. You may increase the limit by authenticating and upgrading . Cause \u00b6 This is caused by DockerHub\u2019s pull rate limit (see https://docs.docker.com/docker-hub/download-rate-limit/ ), which limits pulls from unauthenticated/anonymous users to 100 pulls per hour and for authenticated users (not paying customers) to 200 pulls per hour (as of the time of writing). Solution \u00b6 a) use images from a private registry, e.g. configured as a pull-through cache for DockerHub b) use a different public registry without such limitations, if the same image is stored there c) authenticate containerd inside k3s/k3d to use your DockerHub user (c) Authenticate Containerd against DockerHub \u00b6 Create a registry configuration file for containerd: # saved as e.g. $HOME/registries.yaml configs : \"docker.io\" : auth : username : \"$USERNAME\" password : \"$PASSWORD\" Create a k3d cluster using that config: k3d cluster create --registry-config $HOME /registries.yaml Profit. That\u2019s it. In the test for this, we pulled the same image 120 times in a row (confirmed, that pull numbers went up), without being rate limited (as a non-paying, normal user) Longhorn in k3d \u00b6 Problem \u00b6 Longhorn is not working when deployed in a K3s cluster spawned with k3d. Cause \u00b6 The container image of K3s is quite limited and doesn\u2019t contain the necessary libraries. Also, additional volume mounts and more would be required to get Longhorn up and running properly. So basically Longhorn does rely too much on the host OS to work properly in the dockerized environment without quite some modifications. Solution \u00b6 There are a few ways one can build a working image to use with k3d. See https://github.com/k3d-io/k3d/discussions/478 for more info.","title":"FAQ"},{"location":"faq/faq/#faq","text":"","title":"FAQ"},{"location":"faq/faq/#issues-with-btrfs","text":"As @jaredallard pointed out , people running k3d on a system with btrfs , may need to mount /dev/mapper into the nodes for the setup to work. This will do: k3d cluster create CLUSTER_NAME -v /dev/mapper:/dev/mapper","title":"Issues with BTRFS"},{"location":"faq/faq/#issues-with-zfs","text":"k3s currently has no support for ZFS and thus, creating multi-server setups (e.g. k3d cluster create multiserver --servers 3 ) fails, because the initializing server node (server flag --cluster-init ) errors out with the following log: starting kubernetes: preparing server: start cluster and https: raft_init () : io: create I/O capabilities probe file: posix_allocate: operation not supported on socket This issue can be worked around by providing docker with a different filesystem (that\u2019s also better for docker-in-docker stuff). A possible solution can be found here: https://github.com/rancher/k3s/issues/1688#issuecomment-619570374","title":"Issues with ZFS"},{"location":"faq/faq/#pods-evicted-due-to-lack-of-disk-space","text":"Pods go to evicted state after doing X Related issues: #133 - Pods evicted due to NodeHasDiskPressure (collection of #119 and #130) Background: somehow docker runs out of space for the k3d node containers, which triggers a hard eviction in the kubelet Possible fix/workaround by @zer0def : use a docker storage driver which cleans up properly (e.g. overlay2) clean up or expand docker root filesystem change the kubelet\u2019s eviction thresholds upon cluster creation: k3d cluster create \\ --k3s-arg '--kubelet-arg=eviction-hard=imagefs.available<1%,nodefs.available<1%@agent:*' \\ --k3s-arg '--kubelet-arg=eviction-minimum-reclaim=imagefs.available=1%,nodefs.available=1%@agent:*'","title":"Pods evicted due to lack of disk space"},{"location":"faq/faq/#restarting-a-multi-server-cluster-or-the-initializing-server-node-fails","text":"What you do: You create a cluster with more than one server node and later, you either stop server-0 or stop/start the whole cluster What fails: After the restart, you cannot connect to the cluster anymore and kubectl will give you a lot of errors What causes this issue: it\u2019s a known issue with dqlite in k3s which doesn\u2019t allow the initializing server node to go down What\u2019s the solution: Hopefully, this will be solved by the planned replacement of dqlite with embedded etcd in k3s Related issues: #262","title":"Restarting a multi-server cluster or the initializing server node fails"},{"location":"faq/faq/#passing-additional-argumentsflags-to-k3s-and-on-to-eg-the-kube-apiserver","text":"The Problem: Passing a feature flag to the Kubernetes API Server running inside k3s. Example: you want to enable the EphemeralContainers feature flag in Kubernetes Solution: k3d cluster create \\ --k3s-arg '--kube-apiserver-arg=feature-gates=EphemeralContainers=true@server:*' \\ --k3s-arg '--kube-scheduler-arg=feature-gates=EphemeralContainers=true@server:*' \\ --k3s-arg '--kubelet-arg=feature-gates=EphemeralContainers=true@agent:*' Note : Be aware of where the flags require dashes ( -- ) and where not. the k3s flag ( --kube-apiserver-arg ) has the dashes the kube-apiserver flag feature-gates doesn\u2019t have them (k3s adds them internally) Second example: k3d cluster create k3d-one \\ --k3s-arg \"--cluster-cidr=10.118.0.0/17@server:*\" \\ --k3s-arg \"--service-cidr=10.118.128.0/17@server:*\" \\ --k3s-arg \"--disable=servicelb@server:*\" \\ --k3s-arg \"--disable=traefik@server:*\" \\ --verbose Note : There are many ways to use the \" and ' quotes, just be aware, that sometimes shells also try to interpret/interpolate parts of the commands","title":"Passing additional arguments/flags to k3s (and on to e.g. the kube-apiserver)"},{"location":"faq/faq/#how-to-access-services-like-a-database-running-on-my-docker-host-machine","text":"As of version v3.1.0, we\u2019re injecting the host.k3d.internal entry into the k3d containers (k3s nodes) and into the CoreDNS ConfigMap, enabling you to access your host system by referring to it as host.k3d.internal","title":"How to access services (like a database) running on my Docker Host Machine"},{"location":"faq/faq/#running-behind-a-corporate-proxy","text":"Running k3d behind a corporate proxy can lead to some issues with k3d that have already been reported in more than one issue. Some can be fixed by passing the HTTP_PROXY environment variables to k3d, some have to be fixed in docker\u2019s daemon.json file and some are as easy as adding a volume mount.","title":"Running behind a corporate proxy"},{"location":"faq/faq/#pods-fail-to-start-x509-certificate-signed-by-unknown-authority","text":"Example Error Message: Failed to create pod sandbox: rpc error: code = Unknown desc = failed to get sandbox image \"docker.io/rancher/pause:3.1\" : failed to pull image \"docker.io/rancher/pause:3.1\" : failed to pull and unpack image \"docker.io/rancher/pause:3.1\" : failed to resolve reference \"docker.io/rancher/pause:3.1\" : failed to do request: Head https://registry-1.docker.io/v2/rancher/pause/manifests/3.1: x509: certificate signed by unknown authority Problem: inside the container, the certificate of the corporate proxy cannot be validated Possible Solution: Mounting the CA Certificate from your host into the node containers at start time via k3d cluster create --volume /path/to/your/certs.crt:/etc/ssl/certs/yourcert.crt Issue: k3d-io/k3d#535","title":"Pods fail to start: x509: certificate signed by unknown authority"},{"location":"faq/faq/#spurious-pid-entries-in-proc-after-deleting-k3d-cluster-with-shared-mounts","text":"When you perform cluster create and deletion operations multiple times with same cluster name and shared volume mounts , it was observed that grep k3d /proc/*/mountinfo shows many spurious entries Problem: Due to above, at times you\u2019ll see no space left on device: unknown when a pod is scheduled to the nodes If you observe anything of above sort you can check for inaccessible file systems and unmount them by using below command (note: please remove xargs umount -l and check for the diff o/p first) diff <(df -ha | grep pods | awk '{print $NF}') <(df -h | grep pods | awk '{print $NF}') | awk '{print $2}' | xargs umount -l As per the conversation on k3d-io/k3d#594 above issue wasn\u2019t reported/known earlier and so there are high chances that it\u2019s not universal.","title":"Spurious PID entries in /proc after deleting k3d cluster with shared mounts"},{"location":"faq/faq/#solved-nodes-fail-to-start-or-get-stuck-in-notready-state-with-log-nf_conntrack_max-permission-denied","text":"","title":"[SOLVED] Nodes fail to start or get stuck in NotReady state with log nf_conntrack_max: permission denied"},{"location":"faq/faq/#problem","text":"When: This happens when running k3d on a Linux system with a kernel version >= 5.12.2 (and others like >= 5.11.19) when creating a new cluster the node(s) stop or get stuck with a log line like this: <TIMESTAMP> F0516 05:05:31.782902 7 server.go:495] open /proc/sys/net/netfilter/nf_conntrack_max: permission denied Why: The issue was introduced by a change in the Linux kernel ( Changelog 5.12.2 : Commit ), that changed the netfilter_conntrack behavior in a way that kube-proxy is not able to set the nf_conntrack_max value anymore","title":"Problem"},{"location":"faq/faq/#workaround","text":"Workaround: as a workaround, we can tell kube-proxy to not even try to set this value: k3d cluster create \\ --k3s-arg \"--kube-proxy-arg=conntrack-max-per-core=0@server:*\" \\ --k3s-arg \"--kube-proxy-arg=conntrack-max-per-core=0@agent:*\" \\ --image rancher/k3s:v1.20.6-k3s","title":"Workaround"},{"location":"faq/faq/#fix","text":"Note : k3d v4.4.5 already uses rancher/k3s:v1.21.1-k3s1 as the new default k3s image, so no workarounds needed there! This is going to be fixed \u201cupstream\u201d in k3s itself in rancher/k3s#3337 and backported to k3s versions as low as v1.18. The fix was released and backported in k3s, so you don\u2019t need to use the workaround when using one of the following k3s versions (or later ones) v1.18.19-k3s1 ( rancher/k3s#3344 ) v1.19.11-k3s1 ( rancher/k3s#3343 ) v1.20.7-k3s1 ( rancher/k3s#3342 ) v1.21.1-k3s1 ( rancher/k3s#3341 )) Issue Reference: rancher/k3s#607","title":"Fix"},{"location":"faq/faq/#dockerhub-pull-rate-limit","text":"","title":"DockerHub Pull Rate Limit"},{"location":"faq/faq/#problem_1","text":"You\u2019re deploying something to the cluster using an image from DockerHub and the image fails to be pulled, with a 429 response code and a message saying You have reached your pull rate limit. You may increase the limit by authenticating and upgrading .","title":"Problem"},{"location":"faq/faq/#cause","text":"This is caused by DockerHub\u2019s pull rate limit (see https://docs.docker.com/docker-hub/download-rate-limit/ ), which limits pulls from unauthenticated/anonymous users to 100 pulls per hour and for authenticated users (not paying customers) to 200 pulls per hour (as of the time of writing).","title":"Cause"},{"location":"faq/faq/#solution","text":"a) use images from a private registry, e.g. configured as a pull-through cache for DockerHub b) use a different public registry without such limitations, if the same image is stored there c) authenticate containerd inside k3s/k3d to use your DockerHub user","title":"Solution"},{"location":"faq/faq/#c-authenticate-containerd-against-dockerhub","text":"Create a registry configuration file for containerd: # saved as e.g. $HOME/registries.yaml configs : \"docker.io\" : auth : username : \"$USERNAME\" password : \"$PASSWORD\" Create a k3d cluster using that config: k3d cluster create --registry-config $HOME /registries.yaml Profit. That\u2019s it. In the test for this, we pulled the same image 120 times in a row (confirmed, that pull numbers went up), without being rate limited (as a non-paying, normal user)","title":"(c) Authenticate Containerd against DockerHub"},{"location":"faq/faq/#longhorn-in-k3d","text":"","title":"Longhorn in k3d"},{"location":"faq/faq/#problem_2","text":"Longhorn is not working when deployed in a K3s cluster spawned with k3d.","title":"Problem"},{"location":"faq/faq/#cause_1","text":"The container image of K3s is quite limited and doesn\u2019t contain the necessary libraries. Also, additional volume mounts and more would be required to get Longhorn up and running properly. So basically Longhorn does rely too much on the host OS to work properly in the dockerized environment without quite some modifications.","title":"Cause"},{"location":"faq/faq/#solution_1","text":"There are a few ways one can build a working image to use with k3d. See https://github.com/k3d-io/k3d/discussions/478 for more info.","title":"Solution"},{"location":"usage/commands/","text":"Command Tree \u00b6 k3d --verbose # GLOBAL: enable verbose (debug) logging (default: false) --trace # GLOBAL: enable super verbose logging (trace logging) (default: false) --version # show k3d and k3s version -h, --help # GLOBAL: show help text cluster [ CLUSTERNAME ] # default cluster name is 'k3s-default' create -a, --agents # specify how many agent nodes you want to create (integer, default: 0) --agents-memory # specify memory limit for agent containers/nodes (unit, e.g. 1g) --api-port # specify the port on which the cluster will be accessible (format '[HOST:]HOSTPORT', default: random) -c, --config # use a config file (format 'PATH') -e, --env # add environment variables to the nodes (quoted string, format: 'KEY[=VALUE][@NODEFILTER[;NODEFILTER...]]', use flag multiple times) --gpus # [from docker CLI] add GPU devices to the node containers (string, e.g. 'all') -i, --image # specify which k3s image should be used for the nodes (string, default: 'docker.io/rancher/k3s:v1.20.0-k3s2', tag changes per build) --k3s-arg # add additional arguments to the k3s server/agent (quoted string, use flag multiple times) (see https://rancher.com/docs/k3s/latest/en/installation/install-options/server-config/#k3s-server-cli-help & https://rancher.com/docs/k3s/latest/en/installation/install-options/agent-config/#k3s-agent-cli-help) --kubeconfig-switch-context # (implies --kubeconfig-update-default) automatically sets the current-context of your default kubeconfig to the new cluster's context (default: true) --kubeconfig-update-default # enable the automated update of the default kubeconfig with the details of the newly created cluster (also sets '--wait=true') (default: true) -l, --label # add (docker) labels to the node containers (format: 'KEY[=VALUE][@NODEFILTER[;NODEFILTER...]]', use flag multiple times) --network # specify an existing (docker) network you want to connect to (string) --no-hostip # disable the automatic injection of the Host IP as 'host.k3d.internal' into the containers and CoreDNS (default: false) --no-image-volume # disable the creation of a volume for storing images (used for the 'k3d image import' command) (default: false) --no-lb # disable the creation of a load balancer in front of the server nodes (default: false) --no-rollback # disable the automatic rollback actions, if anything goes wrong (default: false) -p, --port # add some more port mappings (format: '[HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER]', use flag multiple times) --registry-create # create a new (docker) registry dedicated for this cluster (default: false) --registry-use # use an existing local (docker) registry with this cluster (string, use multiple times) -s, --servers # specify how many server nodes you want to create (integer, default: 1) --servers-memory # specify memory limit for server containers/nodes (unit, e.g. 1g) --token # specify a cluster token (string, default: auto-generated) --timeout # specify a timeout, after which the cluster creation will be interrupted and changes rolled back (duration, e.g. '10s') -v, --volume # specify additional bind-mounts (format: '[SOURCE:]DEST[@NODEFILTER[;NODEFILTER...]]', use flag multiple times) --wait # enable waiting for all server nodes to be ready before returning (default: true) start CLUSTERNAME # start a (stopped) cluster -a, --all # start all clusters (default: false) --wait # wait for all servers and server-loadbalancer to be up before returning (default: true) --timeout # maximum waiting time for '--wait' before canceling/returning (duration, e.g. '10s') stop CLUSTERNAME # stop a cluster -a, --all # stop all clusters (default: false) delete CLUSTERNAME # delete an existing cluster -a, --all # delete all existing clusters (default: false) list [ CLUSTERNAME [ CLUSTERNAME ... ]] --no-headers # do not print headers (default: false) --token # show column with cluster tokens (default: false) -o, --output # format the output (format: 'json|yaml') completion [ bash | zsh | fish | ( psh | powershell )] # generate completion scripts for common shells config init # write a default k3d config (as a starting point) -f, --force # force overwrite target file (default: false) -o, --output # file to write to (string, default \"k3d-default.yaml\") help [ COMMAND ] # show help text for any command image import [ IMAGE | ARCHIVE [ IMAGE | ARCHIVE ... ]] # Load one or more images from the local runtime environment or tar-archives into k3d clusters -c, --cluster # clusters to load the image into (string, use flag multiple times, default: k3s-default) -k, --keep-tarball # do not delete the image tarball from the shared volume after completion (default: false) kubeconfig get ( CLUSTERNAME [ CLUSTERNAME ... ] | --all ) # get kubeconfig from cluster(s) and write it to stdout -a, --all # get kubeconfigs from all clusters (default: false) merge | write ( CLUSTERNAME [ CLUSTERNAME ... ] | --all ) # get kubeconfig from cluster(s) and merge it/them into a (kubeconfig-)file -a, --all # get kubeconfigs from all clusters (default: false) -s, --kubeconfig-switch-context # switch current-context in kubeconfig to the new context (default: true) -d, --kubeconfig-merge-default # update the default kubeconfig (usually $KUBECONFIG or $HOME/.kube/config) -o, --output # specify the output file where the kubeconfig should be written to (string) --overwrite # [Careful!] forcefully overwrite the output file, ignoring existing contents (default: false) -u, --update # update conflicting fields in existing kubeconfig (default: true) node create NODENAME # Create new nodes (and add them to existing clusters) -c, --cluster # specify the cluster that the node shall connect to (string, default: k3s-default) -i, --image # specify which k3s image should be used for the node(s) (string, default: 'docker.io/rancher/k3s:v1.20.0-k3s2', tag changes per build) --replicas # specify how many replicas you want to create with this spec (integer, default: 1) --role # specify the node role (string, format: 'agent|server', default: agent) --timeout # specify a timeout duration, after which the node creation will be interrupted, if not done yet (duration, e.g. '10s') --wait # wait for the node to be up and running before returning (default: true) start NODENAME # start a (stopped) node stop NODENAME # stop a node delete NODENAME # delete an existing node -a, --all # delete all existing nodes (default: false) -r, --registries # also delete registries, as a special type of node (default: false) list NODENAME --no-headers # do not print headers (default: false) registry create REGISTRYNAME -i, --image # specify image used for the registry (string, default: \"docker.io/library/registry:2\") -p, --port # select host port to map to (format: '[HOST:]HOSTPORT', default: 'random') delete REGISTRYNAME -a, --all # delete all existing registries (default: false) list [ NAME [ NAME... ]] --no-headers # disable table headers (default: false) version # show k3d and k3s version","title":"Command Tree"},{"location":"usage/commands/#command-tree","text":"k3d --verbose # GLOBAL: enable verbose (debug) logging (default: false) --trace # GLOBAL: enable super verbose logging (trace logging) (default: false) --version # show k3d and k3s version -h, --help # GLOBAL: show help text cluster [ CLUSTERNAME ] # default cluster name is 'k3s-default' create -a, --agents # specify how many agent nodes you want to create (integer, default: 0) --agents-memory # specify memory limit for agent containers/nodes (unit, e.g. 1g) --api-port # specify the port on which the cluster will be accessible (format '[HOST:]HOSTPORT', default: random) -c, --config # use a config file (format 'PATH') -e, --env # add environment variables to the nodes (quoted string, format: 'KEY[=VALUE][@NODEFILTER[;NODEFILTER...]]', use flag multiple times) --gpus # [from docker CLI] add GPU devices to the node containers (string, e.g. 'all') -i, --image # specify which k3s image should be used for the nodes (string, default: 'docker.io/rancher/k3s:v1.20.0-k3s2', tag changes per build) --k3s-arg # add additional arguments to the k3s server/agent (quoted string, use flag multiple times) (see https://rancher.com/docs/k3s/latest/en/installation/install-options/server-config/#k3s-server-cli-help & https://rancher.com/docs/k3s/latest/en/installation/install-options/agent-config/#k3s-agent-cli-help) --kubeconfig-switch-context # (implies --kubeconfig-update-default) automatically sets the current-context of your default kubeconfig to the new cluster's context (default: true) --kubeconfig-update-default # enable the automated update of the default kubeconfig with the details of the newly created cluster (also sets '--wait=true') (default: true) -l, --label # add (docker) labels to the node containers (format: 'KEY[=VALUE][@NODEFILTER[;NODEFILTER...]]', use flag multiple times) --network # specify an existing (docker) network you want to connect to (string) --no-hostip # disable the automatic injection of the Host IP as 'host.k3d.internal' into the containers and CoreDNS (default: false) --no-image-volume # disable the creation of a volume for storing images (used for the 'k3d image import' command) (default: false) --no-lb # disable the creation of a load balancer in front of the server nodes (default: false) --no-rollback # disable the automatic rollback actions, if anything goes wrong (default: false) -p, --port # add some more port mappings (format: '[HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER]', use flag multiple times) --registry-create # create a new (docker) registry dedicated for this cluster (default: false) --registry-use # use an existing local (docker) registry with this cluster (string, use multiple times) -s, --servers # specify how many server nodes you want to create (integer, default: 1) --servers-memory # specify memory limit for server containers/nodes (unit, e.g. 1g) --token # specify a cluster token (string, default: auto-generated) --timeout # specify a timeout, after which the cluster creation will be interrupted and changes rolled back (duration, e.g. '10s') -v, --volume # specify additional bind-mounts (format: '[SOURCE:]DEST[@NODEFILTER[;NODEFILTER...]]', use flag multiple times) --wait # enable waiting for all server nodes to be ready before returning (default: true) start CLUSTERNAME # start a (stopped) cluster -a, --all # start all clusters (default: false) --wait # wait for all servers and server-loadbalancer to be up before returning (default: true) --timeout # maximum waiting time for '--wait' before canceling/returning (duration, e.g. '10s') stop CLUSTERNAME # stop a cluster -a, --all # stop all clusters (default: false) delete CLUSTERNAME # delete an existing cluster -a, --all # delete all existing clusters (default: false) list [ CLUSTERNAME [ CLUSTERNAME ... ]] --no-headers # do not print headers (default: false) --token # show column with cluster tokens (default: false) -o, --output # format the output (format: 'json|yaml') completion [ bash | zsh | fish | ( psh | powershell )] # generate completion scripts for common shells config init # write a default k3d config (as a starting point) -f, --force # force overwrite target file (default: false) -o, --output # file to write to (string, default \"k3d-default.yaml\") help [ COMMAND ] # show help text for any command image import [ IMAGE | ARCHIVE [ IMAGE | ARCHIVE ... ]] # Load one or more images from the local runtime environment or tar-archives into k3d clusters -c, --cluster # clusters to load the image into (string, use flag multiple times, default: k3s-default) -k, --keep-tarball # do not delete the image tarball from the shared volume after completion (default: false) kubeconfig get ( CLUSTERNAME [ CLUSTERNAME ... ] | --all ) # get kubeconfig from cluster(s) and write it to stdout -a, --all # get kubeconfigs from all clusters (default: false) merge | write ( CLUSTERNAME [ CLUSTERNAME ... ] | --all ) # get kubeconfig from cluster(s) and merge it/them into a (kubeconfig-)file -a, --all # get kubeconfigs from all clusters (default: false) -s, --kubeconfig-switch-context # switch current-context in kubeconfig to the new context (default: true) -d, --kubeconfig-merge-default # update the default kubeconfig (usually $KUBECONFIG or $HOME/.kube/config) -o, --output # specify the output file where the kubeconfig should be written to (string) --overwrite # [Careful!] forcefully overwrite the output file, ignoring existing contents (default: false) -u, --update # update conflicting fields in existing kubeconfig (default: true) node create NODENAME # Create new nodes (and add them to existing clusters) -c, --cluster # specify the cluster that the node shall connect to (string, default: k3s-default) -i, --image # specify which k3s image should be used for the node(s) (string, default: 'docker.io/rancher/k3s:v1.20.0-k3s2', tag changes per build) --replicas # specify how many replicas you want to create with this spec (integer, default: 1) --role # specify the node role (string, format: 'agent|server', default: agent) --timeout # specify a timeout duration, after which the node creation will be interrupted, if not done yet (duration, e.g. '10s') --wait # wait for the node to be up and running before returning (default: true) start NODENAME # start a (stopped) node stop NODENAME # stop a node delete NODENAME # delete an existing node -a, --all # delete all existing nodes (default: false) -r, --registries # also delete registries, as a special type of node (default: false) list NODENAME --no-headers # do not print headers (default: false) registry create REGISTRYNAME -i, --image # specify image used for the registry (string, default: \"docker.io/library/registry:2\") -p, --port # select host port to map to (format: '[HOST:]HOSTPORT', default: 'random') delete REGISTRYNAME -a, --all # delete all existing registries (default: false) list [ NAME [ NAME... ]] --no-headers # disable table headers (default: false) version # show k3d and k3s version","title":"Command Tree"},{"location":"usage/configfile/","text":"Using Config Files \u00b6 The config file feature is available as of k3d v4.0.0 Introduction \u00b6 Syntax & Semantics The options defined in the config file are not 100% the same as the CLI flags. This concerns naming and style/usage/structure, e.g. --api-port is split up into a field named kubeAPI that has 3 different \u201cchild fields\u201d ( host , hostIP and hostPort ) k3d options are bundled in a scope named options.k3d , where --no-rollback is defined as options.k3d.disableRollback repeatable flags (like --port ) are reflected as YAML lists Usage \u00b6 Using a config file is as easy as putting it in a well-known place in your file system and then referencing it via flag: All options in config file: k3d cluster create --config /home/me/my-awesome-config.yaml (must be .yaml / .yml ) With CLI override (name): k3d cluster create somename --config /home/me/my-awesome-config.yaml With CLI override (extra volume): k3d cluster create --config /home/me/my-awesome-config.yaml --volume '/some/path:/some:path@server:0' Required Fields \u00b6 As of the time of writing this documentation, the config file only requires you to define two fields: apiVersion to match the version of the config file that you want to use (at this time it would be apiVersion: k3d.io/v1alpha5 ) kind to define the kind of config file that you want to use (currently we only have the Simple config) So this would be the minimal config file, which configures absolutely nothing: apiVersion : k3d.io/v1alpha5 kind : Simple Config Options \u00b6 The configuration options for k3d are continuously evolving and so is the config file (syntax) itself. Currently, the config file is still in an Alpha-State, meaning, that it is subject to change anytime (though we try to keep breaking changes low). Validation via JSON-Schema k3d uses a JSON-Schema to describe the expected format and fields of the configuration file. This schema is also used to validate a user-given config file. This JSON-Schema can be found in the specific config version sub-directory in the repository (e.g. here for v1alpha5 ) and could be used to lookup supported fields or by linters to validate the config file, e.g. in your code editor. All Options: Example \u00b6 Since the config options and the config file are changing quite a bit, it\u2019s hard to keep track of all the supported config file settings, so here\u2019s an example showing all of them as of the time of writing: # k3d configuration file, saved as e.g. /home/me/myk3dcluster.yaml apiVersion : k3d.io/v1alpha5 # this will change in the future as we make everything more stable kind : Simple # internally, we also have a Cluster config, which is not yet available externally metadata : name : mycluster # name that you want to give to your cluster (will still be prefixed with `k3d-`) servers : 1 # same as `--servers 1` agents : 2 # same as `--agents 2` kubeAPI : # same as `--api-port myhost.my.domain:6445` (where the name would resolve to 127.0.0.1) host : \"myhost.my.domain\" # important for the `server` setting in the kubeconfig hostIP : \"127.0.0.1\" # where the Kubernetes API will be listening on hostPort : \"6445\" # where the Kubernetes API listening port will be mapped to on your host system image : rancher/k3s:v1.20.4-k3s1 # same as `--image rancher/k3s:v1.20.4-k3s1` network : my-custom-net # same as `--network my-custom-net` subnet : \"172.28.0.0/16\" # same as `--subnet 172.28.0.0/16` token : superSecretToken # same as `--token superSecretToken` volumes : # repeatable flags are represented as YAML lists - volume : /my/host/path:/path/in/node # same as `--volume '/my/host/path:/path/in/node@server:0;agent:*'` nodeFilters : - server:0 - agent:* ports : - port : 8080:80 # same as `--port '8080:80@loadbalancer'` nodeFilters : - loadbalancer env : - envVar : bar=baz # same as `--env 'bar=baz@server:0'` nodeFilters : - server:0 registries : # define how registries should be created or used create : # creates a default registry to be used with the cluster; same as `--registry-create registry.localhost` name : registry.localhost host : \"0.0.0.0\" hostPort : \"5000\" proxy : # omit this to have a \"normal\" registry, set this to create a registry proxy (pull-through cache) remoteURL : https://registry-1.docker.io # mirror the DockerHub registry username : \"\" # unauthenticated password : \"\" # unauthenticated volumes : - /some/path:/var/lib/registry # persist registry data locally use : - k3d-myotherregistry:5000 # some other k3d-managed registry; same as `--registry-use 'k3d-myotherregistry:5000'` config : | # define contents of the `registries.yaml` file (or reference a file); same as `--registry-config /path/to/config.yaml` mirrors: \"my.company.registry\": endpoint: - http://my.company.registry:5000 hostAliases : # /etc/hosts style entries to be injected into /etc/hosts in the node containers and in the NodeHosts section in CoreDNS - ip : 1.2.3.4 hostnames : - my.host.local - that.other.local - ip : 1.1.1.1 hostnames : - cloud.flare.dns options : k3d : # k3d runtime settings wait : true # wait for cluster to be usable before returning; same as `--wait` (default: true) timeout : \"60s\" # wait timeout before aborting; same as `--timeout 60s` disableLoadbalancer : false # same as `--no-lb` disableImageVolume : false # same as `--no-image-volume` disableRollback : false # same as `--no-Rollback` loadbalancer : configOverrides : - settings.workerConnections=2048 k3s : # options passed on to K3s itself extraArgs : # additional arguments passed to the `k3s server|agent` command; same as `--k3s-arg` - arg : \"--tls-san=my.host.domain\" nodeFilters : - server:* nodeLabels : - label : foo=bar # same as `--k3s-node-label 'foo=bar@agent:1'` -> this results in a Kubernetes node label nodeFilters : - agent:1 kubeconfig : updateDefaultKubeconfig : true # add new cluster to your default Kubeconfig; same as `--kubeconfig-update-default` (default: true) switchCurrentContext : true # also set current-context to the new cluster's context; same as `--kubeconfig-switch-context` (default: true) runtime : # runtime (docker) specific options gpuRequest : all # same as `--gpus all` labels : - label : bar=baz # same as `--runtime-label 'bar=baz@agent:1'` -> this results in a runtime (docker) container label nodeFilters : - agent:1 ulimits : - name : nofile soft : 26677 hard : 26677 Tips \u00b6 k3d expands environment variables ( $VAR or ${VAR} ) unconditionally in the config file, even before processing it in any way. Config File vs. CLI Flags \u00b6 k3d uses Cobra and Viper for CLI and general config handling respectively. This automatically introduces a \u201cconfig option order of priority\u201d ( precedence order ): Config Precedence Order Source: spf13/viper#why-viper Internal Setting > CLI Flag > Environment Variable > Config File > (k/v store >) Defaults This means, that you can define e.g. a \u201cbase configuration file\u201d with settings that you share across different clusters and override only the fields that differ between those clusters in your CLI flags/arguments. For example, you use the same config file to create three clusters which only have different names and kubeAPI ( --api-port ) settings. References \u00b6 k3d demo repository: https://github.com/iwilltry42/k3d-demo/blob/main/README.md#config-file-support SUSE Blog: https://www.suse.com/c/introduction-k3d-run-k3s-docker-src/ (Search for The \u201cConfiguration as Code\u201d Way )","title":"Using Config Files"},{"location":"usage/configfile/#using-config-files","text":"The config file feature is available as of k3d v4.0.0","title":"Using Config Files"},{"location":"usage/configfile/#introduction","text":"Syntax & Semantics The options defined in the config file are not 100% the same as the CLI flags. This concerns naming and style/usage/structure, e.g. --api-port is split up into a field named kubeAPI that has 3 different \u201cchild fields\u201d ( host , hostIP and hostPort ) k3d options are bundled in a scope named options.k3d , where --no-rollback is defined as options.k3d.disableRollback repeatable flags (like --port ) are reflected as YAML lists","title":"Introduction"},{"location":"usage/configfile/#usage","text":"Using a config file is as easy as putting it in a well-known place in your file system and then referencing it via flag: All options in config file: k3d cluster create --config /home/me/my-awesome-config.yaml (must be .yaml / .yml ) With CLI override (name): k3d cluster create somename --config /home/me/my-awesome-config.yaml With CLI override (extra volume): k3d cluster create --config /home/me/my-awesome-config.yaml --volume '/some/path:/some:path@server:0'","title":"Usage"},{"location":"usage/configfile/#required-fields","text":"As of the time of writing this documentation, the config file only requires you to define two fields: apiVersion to match the version of the config file that you want to use (at this time it would be apiVersion: k3d.io/v1alpha5 ) kind to define the kind of config file that you want to use (currently we only have the Simple config) So this would be the minimal config file, which configures absolutely nothing: apiVersion : k3d.io/v1alpha5 kind : Simple","title":"Required Fields"},{"location":"usage/configfile/#config-options","text":"The configuration options for k3d are continuously evolving and so is the config file (syntax) itself. Currently, the config file is still in an Alpha-State, meaning, that it is subject to change anytime (though we try to keep breaking changes low). Validation via JSON-Schema k3d uses a JSON-Schema to describe the expected format and fields of the configuration file. This schema is also used to validate a user-given config file. This JSON-Schema can be found in the specific config version sub-directory in the repository (e.g. here for v1alpha5 ) and could be used to lookup supported fields or by linters to validate the config file, e.g. in your code editor.","title":"Config Options"},{"location":"usage/configfile/#all-options-example","text":"Since the config options and the config file are changing quite a bit, it\u2019s hard to keep track of all the supported config file settings, so here\u2019s an example showing all of them as of the time of writing: # k3d configuration file, saved as e.g. /home/me/myk3dcluster.yaml apiVersion : k3d.io/v1alpha5 # this will change in the future as we make everything more stable kind : Simple # internally, we also have a Cluster config, which is not yet available externally metadata : name : mycluster # name that you want to give to your cluster (will still be prefixed with `k3d-`) servers : 1 # same as `--servers 1` agents : 2 # same as `--agents 2` kubeAPI : # same as `--api-port myhost.my.domain:6445` (where the name would resolve to 127.0.0.1) host : \"myhost.my.domain\" # important for the `server` setting in the kubeconfig hostIP : \"127.0.0.1\" # where the Kubernetes API will be listening on hostPort : \"6445\" # where the Kubernetes API listening port will be mapped to on your host system image : rancher/k3s:v1.20.4-k3s1 # same as `--image rancher/k3s:v1.20.4-k3s1` network : my-custom-net # same as `--network my-custom-net` subnet : \"172.28.0.0/16\" # same as `--subnet 172.28.0.0/16` token : superSecretToken # same as `--token superSecretToken` volumes : # repeatable flags are represented as YAML lists - volume : /my/host/path:/path/in/node # same as `--volume '/my/host/path:/path/in/node@server:0;agent:*'` nodeFilters : - server:0 - agent:* ports : - port : 8080:80 # same as `--port '8080:80@loadbalancer'` nodeFilters : - loadbalancer env : - envVar : bar=baz # same as `--env 'bar=baz@server:0'` nodeFilters : - server:0 registries : # define how registries should be created or used create : # creates a default registry to be used with the cluster; same as `--registry-create registry.localhost` name : registry.localhost host : \"0.0.0.0\" hostPort : \"5000\" proxy : # omit this to have a \"normal\" registry, set this to create a registry proxy (pull-through cache) remoteURL : https://registry-1.docker.io # mirror the DockerHub registry username : \"\" # unauthenticated password : \"\" # unauthenticated volumes : - /some/path:/var/lib/registry # persist registry data locally use : - k3d-myotherregistry:5000 # some other k3d-managed registry; same as `--registry-use 'k3d-myotherregistry:5000'` config : | # define contents of the `registries.yaml` file (or reference a file); same as `--registry-config /path/to/config.yaml` mirrors: \"my.company.registry\": endpoint: - http://my.company.registry:5000 hostAliases : # /etc/hosts style entries to be injected into /etc/hosts in the node containers and in the NodeHosts section in CoreDNS - ip : 1.2.3.4 hostnames : - my.host.local - that.other.local - ip : 1.1.1.1 hostnames : - cloud.flare.dns options : k3d : # k3d runtime settings wait : true # wait for cluster to be usable before returning; same as `--wait` (default: true) timeout : \"60s\" # wait timeout before aborting; same as `--timeout 60s` disableLoadbalancer : false # same as `--no-lb` disableImageVolume : false # same as `--no-image-volume` disableRollback : false # same as `--no-Rollback` loadbalancer : configOverrides : - settings.workerConnections=2048 k3s : # options passed on to K3s itself extraArgs : # additional arguments passed to the `k3s server|agent` command; same as `--k3s-arg` - arg : \"--tls-san=my.host.domain\" nodeFilters : - server:* nodeLabels : - label : foo=bar # same as `--k3s-node-label 'foo=bar@agent:1'` -> this results in a Kubernetes node label nodeFilters : - agent:1 kubeconfig : updateDefaultKubeconfig : true # add new cluster to your default Kubeconfig; same as `--kubeconfig-update-default` (default: true) switchCurrentContext : true # also set current-context to the new cluster's context; same as `--kubeconfig-switch-context` (default: true) runtime : # runtime (docker) specific options gpuRequest : all # same as `--gpus all` labels : - label : bar=baz # same as `--runtime-label 'bar=baz@agent:1'` -> this results in a runtime (docker) container label nodeFilters : - agent:1 ulimits : - name : nofile soft : 26677 hard : 26677","title":"All Options: Example"},{"location":"usage/configfile/#tips","text":"k3d expands environment variables ( $VAR or ${VAR} ) unconditionally in the config file, even before processing it in any way.","title":"Tips"},{"location":"usage/configfile/#config-file-vs-cli-flags","text":"k3d uses Cobra and Viper for CLI and general config handling respectively. This automatically introduces a \u201cconfig option order of priority\u201d ( precedence order ): Config Precedence Order Source: spf13/viper#why-viper Internal Setting > CLI Flag > Environment Variable > Config File > (k/v store >) Defaults This means, that you can define e.g. a \u201cbase configuration file\u201d with settings that you share across different clusters and override only the fields that differ between those clusters in your CLI flags/arguments. For example, you use the same config file to create three clusters which only have different names and kubeAPI ( --api-port ) settings.","title":"Config File vs. CLI Flags"},{"location":"usage/configfile/#references","text":"k3d demo repository: https://github.com/iwilltry42/k3d-demo/blob/main/README.md#config-file-support SUSE Blog: https://www.suse.com/c/introduction-k3d-run-k3s-docker-src/ (Search for The \u201cConfiguration as Code\u201d Way )","title":"References"},{"location":"usage/exposing_services/","text":"Exposing Services \u00b6 1. via Ingress (recommended) \u00b6 In this example, we will deploy a simple nginx webserver deployment and make it accessible via ingress. Therefore, we have to create the cluster in a way, that the internal port 80 (where the traefik ingress controller is listening on) is exposed on the host system. Create a cluster, mapping the ingress port 80 to localhost:8081 k3d cluster create --api-port 6550 -p \"8081:80@loadbalancer\" --agents 2 Good to know --api-port 6550 is not required for the example to work. It\u2019s used to have k3s \u2018s API-Server listening on port 6550 with that port mapped to the host system. the port-mapping construct 8081:80@loadbalancer means: \u201cmap port 8081 from the host to port 80 on the container which matches the nodefilter loadbalancer \u201c the loadbalancer nodefilter matches only the serverlb that\u2019s deployed in front of a cluster\u2019s server nodes all ports exposed on the serverlb will be proxied to the same ports on all server nodes in the cluster Get the kubeconfig file (redundant, as k3d cluster create already merges it into your default kubeconfig file) export KUBECONFIG = \" $( k3d kubeconfig write k3s-default ) \" Create a nginx deployment kubectl create deployment nginx --image = nginx Create a ClusterIP service for it kubectl create service clusterip nginx --tcp = 80 :80 Create an ingress object for it by copying the following manifest to a file and applying with kubectl apply -f thatfile.yaml Note : k3s deploys traefik as the default ingress controller # apiVersion: networking.k8s.io/v1beta1 # for k3s < v1.19 apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : nginx annotations : ingress.kubernetes.io/ssl-redirect : \"false\" spec : rules : - http : paths : - path : / pathType : Prefix backend : service : name : nginx port : number : 80 Curl it via localhost curl localhost:8081/ 2. via NodePort \u00b6 Create a cluster, mapping the port 30080 from agent-0 to localhost:8082 k3d cluster create mycluster -p \"8082:30080@agent:0\" --agents 2 Note 1 : Kubernetes\u2019 default NodePort range is 30000-32767 Note 2 : You may as well expose the whole NodePort range from the very beginning, e.g. via k3d cluster create mycluster --agents 3 -p \"30000-32767:30000-32767@server:0\" (See this video from @portainer ) Warning : Docker creates iptable entries and a new proxy process per port-mapping, so this may take a very long time or even freeze your system! \u2026 (Steps 2 and 3 like above) \u2026 Create a NodePort service for it by copying the following manifest to a file and applying it with kubectl apply -f apiVersion : v1 kind : Service metadata : labels : app : nginx name : nginx spec : ports : - name : 80-80 nodePort : 30080 port : 80 protocol : TCP targetPort : 80 selector : app : nginx type : NodePort Curl it via localhost curl localhost:8082/","title":"Exposing Services"},{"location":"usage/exposing_services/#exposing-services","text":"","title":"Exposing Services"},{"location":"usage/exposing_services/#1-via-ingress-recommended","text":"In this example, we will deploy a simple nginx webserver deployment and make it accessible via ingress. Therefore, we have to create the cluster in a way, that the internal port 80 (where the traefik ingress controller is listening on) is exposed on the host system. Create a cluster, mapping the ingress port 80 to localhost:8081 k3d cluster create --api-port 6550 -p \"8081:80@loadbalancer\" --agents 2 Good to know --api-port 6550 is not required for the example to work. It\u2019s used to have k3s \u2018s API-Server listening on port 6550 with that port mapped to the host system. the port-mapping construct 8081:80@loadbalancer means: \u201cmap port 8081 from the host to port 80 on the container which matches the nodefilter loadbalancer \u201c the loadbalancer nodefilter matches only the serverlb that\u2019s deployed in front of a cluster\u2019s server nodes all ports exposed on the serverlb will be proxied to the same ports on all server nodes in the cluster Get the kubeconfig file (redundant, as k3d cluster create already merges it into your default kubeconfig file) export KUBECONFIG = \" $( k3d kubeconfig write k3s-default ) \" Create a nginx deployment kubectl create deployment nginx --image = nginx Create a ClusterIP service for it kubectl create service clusterip nginx --tcp = 80 :80 Create an ingress object for it by copying the following manifest to a file and applying with kubectl apply -f thatfile.yaml Note : k3s deploys traefik as the default ingress controller # apiVersion: networking.k8s.io/v1beta1 # for k3s < v1.19 apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : nginx annotations : ingress.kubernetes.io/ssl-redirect : \"false\" spec : rules : - http : paths : - path : / pathType : Prefix backend : service : name : nginx port : number : 80 Curl it via localhost curl localhost:8081/","title":"1. via Ingress (recommended)"},{"location":"usage/exposing_services/#2-via-nodeport","text":"Create a cluster, mapping the port 30080 from agent-0 to localhost:8082 k3d cluster create mycluster -p \"8082:30080@agent:0\" --agents 2 Note 1 : Kubernetes\u2019 default NodePort range is 30000-32767 Note 2 : You may as well expose the whole NodePort range from the very beginning, e.g. via k3d cluster create mycluster --agents 3 -p \"30000-32767:30000-32767@server:0\" (See this video from @portainer ) Warning : Docker creates iptable entries and a new proxy process per port-mapping, so this may take a very long time or even freeze your system! \u2026 (Steps 2 and 3 like above) \u2026 Create a NodePort service for it by copying the following manifest to a file and applying it with kubectl apply -f apiVersion : v1 kind : Service metadata : labels : app : nginx name : nginx spec : ports : - name : 80-80 nodePort : 30080 port : 80 protocol : TCP targetPort : 80 selector : app : nginx type : NodePort Curl it via localhost curl localhost:8082/","title":"2. via NodePort"},{"location":"usage/importing_images/","text":"Importing modes \u00b6 Auto \u00b6 Auto-determine whether to use direct or tools-node . For remote container runtimes, tools-node is faster due to less network overhead, thus it is automatically selected for remote runtimes. Otherwise direct is used. Direct \u00b6 Directly load the given images to the k3s nodes. No separate container is spawned, no intermediate files are written. Tools Node \u00b6 Start a k3d-tools container in the container runtime, copy images to that runtime, then load the images to k3s nodes from there.","title":"Importing modes"},{"location":"usage/importing_images/#importing-modes","text":"","title":"Importing modes"},{"location":"usage/importing_images/#auto","text":"Auto-determine whether to use direct or tools-node . For remote container runtimes, tools-node is faster due to less network overhead, thus it is automatically selected for remote runtimes. Otherwise direct is used.","title":"Auto"},{"location":"usage/importing_images/#direct","text":"Directly load the given images to the k3s nodes. No separate container is spawned, no intermediate files are written.","title":"Direct"},{"location":"usage/importing_images/#tools-node","text":"Start a k3d-tools container in the container runtime, copy images to that runtime, then load the images to k3s nodes from there.","title":"Tools Node"},{"location":"usage/k3s/","text":"K3s Features in k3d \u00b6 K3s ships with lots of built-in features and services, some of which may only be used in \u201cnon-normal\u201d ways in k3d due to the fact that K3s is running in containers. General: K3s documentation \u00b6 Automatically Deploying Manifests and Helm Charts: https://rancher.com/docs/k3s/latest/en/helm/#automatically-deploying-manifests-and-helm-charts Note: /var/lib/rancher/k3s/server/manifests is also the path inside the K3s container filesystem, where all built-in component manifests are, so you can override them or provide your own variants by mounting files there, e.g. --volume /path/to/my/custom/coredns.yaml:/var/lib/rancher/k3s/server/manifests/coredns.yaml will override the packaged CoreDNS component. Customizing packaged Components with HelmChartConfig : https://rancher.com/docs/k3s/latest/en/helm/#customizing-packaged-components-with-helmchartconfig CoreDNS \u00b6 Cluster DNS service Resources \u00b6 Manifest embedded in K3s: https://github.com/k3s-io/k3s/blob/master/manifests/coredns.yaml Note: it includes template variables (like %{CLUSTER_DOMAIN}% ) that will be replaced by K3s before writing the file to the filesystem CoreDNS in k3d \u00b6 Basically, CoreDNS works the same in k3d as it does in other clusters. One thing to note though is, that the default forward . /etc/resolv.conf configured in the Corefile doesn\u2019t work the same, as the /etc/resolv.conf file inside the K3s node containers is not the same as the one on your local machine. Modifications \u00b6 As of k3d v5.x, k3d injects entries to the NodeHosts (basically a hosts file similar to /etc/hosts in Linux, which is managed by K3s) to enable Pods in the cluster to resolve the names of other containers in the same docker network (cluster network) and a special entry called host.k3d.internal which resolves to the IP of the network gateway (can be used to e.g. resolve DNS queries using your local resolver). There\u2019s a PR in progress to make customizations easier (for k3d and for users): https://github.com/k3s-io/k3s/pull/4397 local-path-provisioner \u00b6 Dynamically provisioning persistent local storage with Kubernetes Resources \u00b6 Source: https://github.com/rancher/local-path-provisioner Manifest embedded in K3s: https://github.com/k3s-io/k3s/blob/master/manifests/local-storage.yaml local-path-provisioner in k3d \u00b6 In k3d, the local paths that the local-path-provisioner uses (default is /var/lib/rancher/k3s/storage ) lies inside the container\u2019s filesystem, meaning that by default it\u2019s not mapped somewhere e.g. in your user home directory for you to use. You\u2019d need to map some local directory to that path to easily use the files inside this path: add --volume $HOME/some/directory:/var/lib/rancher/k3s/storage@all to your k3d cluster create command. Traefik \u00b6 Kubernetes Ingress Controller Resources \u00b6 Official Documentation: https://doc.traefik.io/traefik/providers/kubernetes-ingress/ Manifest embedded in K3s: https://github.com/k3s-io/k3s/blob/master/manifests/traefik.yaml Traefik in k3d \u00b6 k3d runs K3s in containers, so you\u2019ll need to expose the http/https ports on your host to easily access Ingress resources in your cluster. We have a guide over here explaining how to do this, see servicelb (klipper-lb) \u00b6 Embedded service load balancer in Klipper Allows you to use services with type: LoadBalancer in K3s by creating tiny proxies that use hostPort s Resources \u00b6 Source: https://github.com/k3s-io/klipper-lb servicelb in k3d \u00b6 klipper-lb creates new pods that proxy traffic from hostPort s to the service ports of type: LoadBalancer . The hostPort in this case is a port in a K3s container, not your local host, so you\u2019d need to add the port-mapping via the --port flag when creating the cluster.","title":"K3s Features in k3d"},{"location":"usage/k3s/#k3s-features-in-k3d","text":"K3s ships with lots of built-in features and services, some of which may only be used in \u201cnon-normal\u201d ways in k3d due to the fact that K3s is running in containers.","title":"K3s Features in k3d"},{"location":"usage/k3s/#general-k3s-documentation","text":"Automatically Deploying Manifests and Helm Charts: https://rancher.com/docs/k3s/latest/en/helm/#automatically-deploying-manifests-and-helm-charts Note: /var/lib/rancher/k3s/server/manifests is also the path inside the K3s container filesystem, where all built-in component manifests are, so you can override them or provide your own variants by mounting files there, e.g. --volume /path/to/my/custom/coredns.yaml:/var/lib/rancher/k3s/server/manifests/coredns.yaml will override the packaged CoreDNS component. Customizing packaged Components with HelmChartConfig : https://rancher.com/docs/k3s/latest/en/helm/#customizing-packaged-components-with-helmchartconfig","title":"General: K3s documentation"},{"location":"usage/k3s/#coredns","text":"Cluster DNS service","title":"CoreDNS"},{"location":"usage/k3s/#resources","text":"Manifest embedded in K3s: https://github.com/k3s-io/k3s/blob/master/manifests/coredns.yaml Note: it includes template variables (like %{CLUSTER_DOMAIN}% ) that will be replaced by K3s before writing the file to the filesystem","title":"Resources"},{"location":"usage/k3s/#coredns-in-k3d","text":"Basically, CoreDNS works the same in k3d as it does in other clusters. One thing to note though is, that the default forward . /etc/resolv.conf configured in the Corefile doesn\u2019t work the same, as the /etc/resolv.conf file inside the K3s node containers is not the same as the one on your local machine.","title":"CoreDNS in k3d"},{"location":"usage/k3s/#modifications","text":"As of k3d v5.x, k3d injects entries to the NodeHosts (basically a hosts file similar to /etc/hosts in Linux, which is managed by K3s) to enable Pods in the cluster to resolve the names of other containers in the same docker network (cluster network) and a special entry called host.k3d.internal which resolves to the IP of the network gateway (can be used to e.g. resolve DNS queries using your local resolver). There\u2019s a PR in progress to make customizations easier (for k3d and for users): https://github.com/k3s-io/k3s/pull/4397","title":"Modifications"},{"location":"usage/k3s/#local-path-provisioner","text":"Dynamically provisioning persistent local storage with Kubernetes","title":"local-path-provisioner"},{"location":"usage/k3s/#resources_1","text":"Source: https://github.com/rancher/local-path-provisioner Manifest embedded in K3s: https://github.com/k3s-io/k3s/blob/master/manifests/local-storage.yaml","title":"Resources"},{"location":"usage/k3s/#local-path-provisioner-in-k3d","text":"In k3d, the local paths that the local-path-provisioner uses (default is /var/lib/rancher/k3s/storage ) lies inside the container\u2019s filesystem, meaning that by default it\u2019s not mapped somewhere e.g. in your user home directory for you to use. You\u2019d need to map some local directory to that path to easily use the files inside this path: add --volume $HOME/some/directory:/var/lib/rancher/k3s/storage@all to your k3d cluster create command.","title":"local-path-provisioner in k3d"},{"location":"usage/k3s/#traefik","text":"Kubernetes Ingress Controller","title":"Traefik"},{"location":"usage/k3s/#resources_2","text":"Official Documentation: https://doc.traefik.io/traefik/providers/kubernetes-ingress/ Manifest embedded in K3s: https://github.com/k3s-io/k3s/blob/master/manifests/traefik.yaml","title":"Resources"},{"location":"usage/k3s/#traefik-in-k3d","text":"k3d runs K3s in containers, so you\u2019ll need to expose the http/https ports on your host to easily access Ingress resources in your cluster. We have a guide over here explaining how to do this, see","title":"Traefik in k3d"},{"location":"usage/k3s/#servicelb-klipper-lb","text":"Embedded service load balancer in Klipper Allows you to use services with type: LoadBalancer in K3s by creating tiny proxies that use hostPort s","title":"servicelb (klipper-lb)"},{"location":"usage/k3s/#resources_3","text":"Source: https://github.com/k3s-io/klipper-lb","title":"Resources"},{"location":"usage/k3s/#servicelb-in-k3d","text":"klipper-lb creates new pods that proxy traffic from hostPort s to the service ports of type: LoadBalancer . The hostPort in this case is a port in a K3s container, not your local host, so you\u2019d need to add the port-mapping via the --port flag when creating the cluster.","title":"servicelb in k3d"},{"location":"usage/kubeconfig/","text":"Handling Kubeconfigs \u00b6 By default, k3d will update your default kubeconfig with your new cluster\u2019s details and set the current-context to it (can be disabled). To get a kubeconfig set up for you to connect to a k3d cluster without this automatism, you can go different ways. What is the default kubeconfig? We determine the path of the used or default kubeconfig in two ways: Using the KUBECONFIG environment variable, if it specifies exactly one file Using the default path (e.g. on Linux it\u2019s $HOME /.kube/config ) Getting the kubeconfig for a newly created cluster \u00b6 Create a new kubeconfig file after cluster creation k3d kubeconfig write mycluster Note: this will create (or update) the file $HOME/.k3d/kubeconfig-mycluster.yaml Tip: Use it: export KUBECONFIG = $( k3d kubeconfig write mycluster ) Note 2 : alternatively you can use k3d kubeconfig get mycluster > some-file.yaml Update your default kubeconfig upon cluster creation (DEFAULT) k3d cluster create mycluster --kubeconfig-update-default Note: this won\u2019t switch the current-context (append --kubeconfig-switch-context to do so) Update your default kubeconfig after cluster creation k3d kubeconfig merge mycluster --kubeconfig-merge-default Note: this won\u2019t switch the current-context (append --kubeconfig-switch-context to do so) Update a different kubeconfig after cluster creation k3d kubeconfig merge mycluster --output some/other/file.yaml Note: this won\u2019t switch the current-context The file will be created if it doesn\u2019t exist Switching the current context None of the above options switch the current-context by default. This is intended to be least intrusive, since the current-context has a global effect. You can switch the current-context directly with the kubeconfig merge command by adding the --kubeconfig-switch-context flag. Removing cluster details from the kubeconfig \u00b6 k3d cluster delete mycluster will always remove the details for mycluster from the default kubeconfig. It will also delete the respective kubeconfig file in $HOME/.k3d/ if it exists. Handling multiple clusters \u00b6 k3d kubeconfig merge let\u2019s you specify one or more clusters via arguments or all via --all . All kubeconfigs will then be merged into a single file if --kubeconfig-merge-default or --output is specified. If none of those two flags was specified, a new file will be created per cluster and the merged path (e.g. $HOME/.k3d/kubeconfig-cluster1.yaml:$HOME/.k3d/cluster2.yaml ) will be returned. Note, that with multiple cluster specified, the --kubeconfig-switch-context flag will change the current context to the cluster which was last in the list.","title":"Handling Kubeconfigs"},{"location":"usage/kubeconfig/#handling-kubeconfigs","text":"By default, k3d will update your default kubeconfig with your new cluster\u2019s details and set the current-context to it (can be disabled). To get a kubeconfig set up for you to connect to a k3d cluster without this automatism, you can go different ways. What is the default kubeconfig? We determine the path of the used or default kubeconfig in two ways: Using the KUBECONFIG environment variable, if it specifies exactly one file Using the default path (e.g. on Linux it\u2019s $HOME /.kube/config )","title":"Handling Kubeconfigs"},{"location":"usage/kubeconfig/#getting-the-kubeconfig-for-a-newly-created-cluster","text":"Create a new kubeconfig file after cluster creation k3d kubeconfig write mycluster Note: this will create (or update) the file $HOME/.k3d/kubeconfig-mycluster.yaml Tip: Use it: export KUBECONFIG = $( k3d kubeconfig write mycluster ) Note 2 : alternatively you can use k3d kubeconfig get mycluster > some-file.yaml Update your default kubeconfig upon cluster creation (DEFAULT) k3d cluster create mycluster --kubeconfig-update-default Note: this won\u2019t switch the current-context (append --kubeconfig-switch-context to do so) Update your default kubeconfig after cluster creation k3d kubeconfig merge mycluster --kubeconfig-merge-default Note: this won\u2019t switch the current-context (append --kubeconfig-switch-context to do so) Update a different kubeconfig after cluster creation k3d kubeconfig merge mycluster --output some/other/file.yaml Note: this won\u2019t switch the current-context The file will be created if it doesn\u2019t exist Switching the current context None of the above options switch the current-context by default. This is intended to be least intrusive, since the current-context has a global effect. You can switch the current-context directly with the kubeconfig merge command by adding the --kubeconfig-switch-context flag.","title":"Getting the kubeconfig for a newly created cluster"},{"location":"usage/kubeconfig/#removing-cluster-details-from-the-kubeconfig","text":"k3d cluster delete mycluster will always remove the details for mycluster from the default kubeconfig. It will also delete the respective kubeconfig file in $HOME/.k3d/ if it exists.","title":"Removing cluster details from the kubeconfig"},{"location":"usage/kubeconfig/#handling-multiple-clusters","text":"k3d kubeconfig merge let\u2019s you specify one or more clusters via arguments or all via --all . All kubeconfigs will then be merged into a single file if --kubeconfig-merge-default or --output is specified. If none of those two flags was specified, a new file will be created per cluster and the merged path (e.g. $HOME/.k3d/kubeconfig-cluster1.yaml:$HOME/.k3d/cluster2.yaml ) will be returned. Note, that with multiple cluster specified, the --kubeconfig-switch-context flag will change the current context to the cluster which was last in the list.","title":"Handling multiple clusters"},{"location":"usage/multiserver/","text":"Creating multi-server clusters \u00b6 Important note For the best results (and less unexpected issues), choose 1, 3, 5, \u2026 server nodes. (Read more on etcd quorum on etcd.io ) At least 2 cores and 4GiB of RAM are recommended. Embedded etcd \u00b6 Create a cluster with 3 server nodes using k3s\u2019 embedded etcd database. The first server to be created will use the --cluster-init flag and k3d will wait for it to be up and running before creating (and connecting) the other server nodes. k3d cluster create multiserver --servers 3 Adding server nodes to a running cluster \u00b6 In theory (and also in practice in most cases), this is as easy as executing the following command: k3d node create newserver --cluster multiserver --role server There\u2019s a trap! If your cluster was initially created with only a single server node, then this will fail. That\u2019s because the initial server node was not started with the --cluster-init flag and thus is not using the etcd backend.","title":"Creating multi-server clusters"},{"location":"usage/multiserver/#creating-multi-server-clusters","text":"Important note For the best results (and less unexpected issues), choose 1, 3, 5, \u2026 server nodes. (Read more on etcd quorum on etcd.io ) At least 2 cores and 4GiB of RAM are recommended.","title":"Creating multi-server clusters"},{"location":"usage/multiserver/#embedded-etcd","text":"Create a cluster with 3 server nodes using k3s\u2019 embedded etcd database. The first server to be created will use the --cluster-init flag and k3d will wait for it to be up and running before creating (and connecting) the other server nodes. k3d cluster create multiserver --servers 3","title":"Embedded etcd"},{"location":"usage/multiserver/#adding-server-nodes-to-a-running-cluster","text":"In theory (and also in practice in most cases), this is as easy as executing the following command: k3d node create newserver --cluster multiserver --role server There\u2019s a trap! If your cluster was initially created with only a single server node, then this will fail. That\u2019s because the initial server node was not started with the --cluster-init flag and thus is not using the etcd backend.","title":"Adding server nodes to a running cluster"},{"location":"usage/registries/","text":"Using Image Registries \u00b6 Registries configuration file \u00b6 You can add registries by specifying them in a registries.yaml and referencing it at creation time: k3d cluster create mycluster --registry-config \"/home/YOU/my-registries.yaml\" . This file is a regular k3s registries configuration file , and looks like this: mirrors : \"my.company.registry:5000\" : endpoint : - http://my.company.registry:5000 In this example, an image with a name like my.company.registry:5000/nginx:latest would be pulled from the registry running at http://my.company.registry:5000 . This file can also be used for providing additional information necessary for accessing some registries, like authentication and certificates . Registries Configuration File embedded in k3d\u2019s SimpleConfig \u00b6 If you\u2019re using a SimpleConfig file to configure your k3d cluster, you may as well embed the registries.yaml in there directly: apiVersion : k3d.io/v1alpha5 kind : Simple metadata : name : test servers : 1 agents : 2 registries : create : name : myregistry config : | mirrors: \"my.company.registry\": endpoint: - http://my.company.registry:5000 Here, the config for the k3d-managed registry, created by the create: {...} option will be merged with the config specified under config: | . Authenticated registries \u00b6 When using authenticated registries, we can add the username and password in a configs section in the registries.yaml , like this: mirrors : my.company.registry : endpoint : - http://my.company.registry configs : my.company.registry : auth : username : aladin password : abracadabra Secure registries \u00b6 When using secure registries, the registries.yaml file must include information about the certificates. For example, if you want to use images from the secure registry running at https://my.company.registry , you must first download a CA file valid for that server and store it in some well-known directory like ${HOME}/.k3d/my-company-root.pem . Then you have to mount the CA file in some directory in the nodes in the cluster and include that mounted file in a configs section in the registries.yaml file . For example, if we mount the CA file in /etc/ssl/certs/my-company-root.pem , the registries.yaml will look like: mirrors : my.company.registry : endpoint : - https://my.company.registry configs : my.company.registry : tls : # we will mount \"my-company-root.pem\" in the /etc/ssl/certs/ directory. ca_file : \"/etc/ssl/certs/my-company-root.pem\" Finally, we can create the cluster, mounting the CA file in the path we specified in ca_file : k3d cluster create \\ --volume \" ${ HOME } /.k3d/my-registries.yaml:/etc/rancher/k3s/registries.yaml\" \\ --volume \" ${ HOME } /.k3d/my-company-root.pem:/etc/ssl/certs/my-company-root.pem\" Using a local registry \u00b6 Preface: Referencing local registries \u00b6 In the next sections, you\u2019re going to create a local registry (i.e. a container image registry running in a container in your docker host). That container will have a name, e.g. mycluster-registry . If you follow the guide closely (or definitely if you use the k3d-managed option), this name will be known to all the hosts (K3s containers) and workloads in your k3d cluster. However, you usually want to push images into that registry from your local machine, which does not know that name by default. Now you have a few options, including the following three: Use localhost : Since the container will have a port mapped to your local host, you can just directly reference it via e.g. localhost:12345 , where 12345 is the mapped port If you later pull the image from the registry, only the repository path (e.g. myrepo/myimage:mytag in mycluster-registry:5000/myrepo/myimage:mytag ) matters to find your image in the targeted registry. Get your machine to know the container name: For this you can use the plain old hosts file ( /etc/hosts on Unix systems and C:\\windows\\system32\\drivers\\etc\\hosts on Windows) by adding an entry like the following to the end of the file: 127.0.0.1 mycluster-registry Use some special resolving magic: Tools like dnsmasq or nss-myhostname (see info box below) and others can setup your local resolver to directly resolve the registry name to 127.0.0.1 . nss-myhostname to resolve *.localhost Luckily (for Linux users), NSS-myhostname ships with many Linux distributions and should resolve *.localhost automatically to 127.0.0.1 . Otherwise, it\u2019s installable using sudo apt install libnss-myhostname . Using k3d-managed registries \u00b6 Create a dedicated registry together with your cluster \u00b6 k3d cluster create mycluster --registry-create mycluster-registry : This creates your cluster mycluster together with a registry container called mycluster-registry k3d sets everything up in the cluster for containerd to be able to pull images from that registry (using the registries.yaml file) the port, which the registry is listening on will be mapped to a random port on your host system Check the k3d command output or docker ps -f name = mycluster-registry to find the exposed port Test your registry Create a customized k3d-managed registry \u00b6 k3d registry create myregistry.localhost --port 12345 creates a new registry called k3d-myregistry.localhost (could be used with automatic resolution of *.localhost , see next section - also, note the k3d- prefix that k3d adds to all resources it creates) k3d cluster create newcluster --registry-use k3d-myregistry.localhost:12345 (make sure you use the k3d- prefix here) creates a new cluster set up to use that registry Test your registry Using your own (not k3d-managed) local registry \u00b6 We recommend using a k3d-managed registry, as it plays nicely together with k3d clusters, but here\u2019s also a guide to create your own (not k3d-managed) registry, if you need features or customizations, that k3d does not provide: Using your own (not k3d-managed) local registry You can start your own local registry it with some docker commands, like: docker volume create local_registry docker container run -d --name registry.localhost -v local_registry:/var/lib/registry --restart always -p 12345 :5000 registry:2 These commands will start your registry container with name and port (on your host) registry.localhost:12345 . In order to push to this registry, you will need to make it accessible as described in the next section. Once your registry is up and running, we will need to add it to your registries.yaml configuration file. Finally, you have to connect the registry network to the k3d cluster network: docker network connect k3d-k3s-default registry.localhost . And then you can test your local registry . Pushing to your local registry address \u00b6 See Preface The information below has been addressed in the preface for this section . Testing your registry \u00b6 You should test that you can push to your registry from your local development machine. use images from that registry in Deployments in your k3d cluster. We will verify these two things for a local registry (located at k3d-registry.localhost:12345 ) running in your development machine. Things would be basically the same for checking an external registry, but some additional configuration could be necessary in your local machine when using an authenticated or secure registry (please refer to Docker\u2019s documentation for this). Assumptions : In the following test cases, we assume that the registry name k3d-registry.localhost resolves to 127.0.0.1 in your local machine (see section preface for more details ) and to the registry container IP for the k3d cluster nodes (K3s containers). Note : as per the explanation in the preface , you could replace k3d-registry.localhost:12345 with localhost:12345 in the docker tag and docker push commands below (but not in the kubectl part!) Nginx Deployment \u00b6 First, we can download some image (like nginx ) and push it to our local registry with: docker pull nginx:latest docker tag nginx:latest k3d-registry.localhost:12345/nginx:latest docker push k3d-registry.localhost:12345/nginx:latest Then we can deploy a pod referencing this image to your cluster: cat <<EOF | kubectl apply -f - apiVersion: apps/v1 kind: Deployment metadata: name: nginx-test-registry labels: app: nginx-test-registry spec: replicas: 1 selector: matchLabels: app: nginx-test-registry template: metadata: labels: app: nginx-test-registry spec: containers: - name: nginx-test-registry image: k3d-registry.localhost:12345/nginx:latest ports: - containerPort: 80 EOF Then you should check that the pod is running with kubectl get pods -l \"app=nginx-test-registry\" . Alpine Pod \u00b6 Pull the alpine image: docker pull alpine:latest re-tag it to reference your newly created registry: docker tag alpine:latest k3d-registry.localhost:12345/testimage:local push it: docker push k3d-registry.localhost:12345/testimage:local Use kubectl to create a new pod in your cluster using that image to see, if the cluster can pull from the new registry: kubectl run --image k3d-registry.localhost:12345/testimage:local testimage --command -- tail -f /dev/null (creates a container that will not do anything but keep on running) Creating a registry proxy / pull-through registry \u00b6 Create a pull-through registry k3d registry create docker-io ` # Create a registry named k3d-docker-io` \\ -p 5000 ` # listening on local host port 5000` \\ --proxy-remote-url https://registry-1.docker.io ` # let it mirror the Docker Hub registry` \\ -v ~/.local/share/docker-io-registry:/var/lib/registry ` # also persist the downloaded images on the device outside the container` Create registry.yml mirrors : \"docker.io\" : endpoint : - http://k3d-docker-io:5000 Create a cluster and using the pull-through cache k3d cluster create cluster01 --registry-use k3d-docker-io:5000 --registry-config registry.yml After cluster01 ready, create another cluster with the same registry or rebuild the cluster, it will use the already locally cached images. k3d cluster create cluster02 --registry-use k3d-docker-io:5000 --registry-config registry.yml Creating a registry proxy / pull-through registry via configfile \u00b6 Create a config file, e.g. /home/me/test-regcache.yaml apiVersion : k3d.io/v1alpha5 kind : Simple metadata : name : test-regcache registries : create : name : docker-io # name of the registry container proxy : remoteURL : https://registry-1.docker.io # proxy DockerHub volumes : - /tmp/reg:/var/lib/registry # persist data locally in /tmp/reg config : | # tell K3s to use this registry when pulling from DockerHub mirrors: \"docker.io\": endpoint: - http://docker-io:5000 Create cluster from config: k3d cluster create -c /home/me/test-regcache.yaml","title":"Using Image Registries"},{"location":"usage/registries/#using-image-registries","text":"","title":"Using Image Registries"},{"location":"usage/registries/#registries-configuration-file","text":"You can add registries by specifying them in a registries.yaml and referencing it at creation time: k3d cluster create mycluster --registry-config \"/home/YOU/my-registries.yaml\" . This file is a regular k3s registries configuration file , and looks like this: mirrors : \"my.company.registry:5000\" : endpoint : - http://my.company.registry:5000 In this example, an image with a name like my.company.registry:5000/nginx:latest would be pulled from the registry running at http://my.company.registry:5000 . This file can also be used for providing additional information necessary for accessing some registries, like authentication and certificates .","title":"Registries configuration file"},{"location":"usage/registries/#registries-configuration-file-embedded-in-k3ds-simpleconfig","text":"If you\u2019re using a SimpleConfig file to configure your k3d cluster, you may as well embed the registries.yaml in there directly: apiVersion : k3d.io/v1alpha5 kind : Simple metadata : name : test servers : 1 agents : 2 registries : create : name : myregistry config : | mirrors: \"my.company.registry\": endpoint: - http://my.company.registry:5000 Here, the config for the k3d-managed registry, created by the create: {...} option will be merged with the config specified under config: | .","title":"Registries Configuration File embedded in k3d's SimpleConfig"},{"location":"usage/registries/#authenticated-registries","text":"When using authenticated registries, we can add the username and password in a configs section in the registries.yaml , like this: mirrors : my.company.registry : endpoint : - http://my.company.registry configs : my.company.registry : auth : username : aladin password : abracadabra","title":"Authenticated registries"},{"location":"usage/registries/#secure-registries","text":"When using secure registries, the registries.yaml file must include information about the certificates. For example, if you want to use images from the secure registry running at https://my.company.registry , you must first download a CA file valid for that server and store it in some well-known directory like ${HOME}/.k3d/my-company-root.pem . Then you have to mount the CA file in some directory in the nodes in the cluster and include that mounted file in a configs section in the registries.yaml file . For example, if we mount the CA file in /etc/ssl/certs/my-company-root.pem , the registries.yaml will look like: mirrors : my.company.registry : endpoint : - https://my.company.registry configs : my.company.registry : tls : # we will mount \"my-company-root.pem\" in the /etc/ssl/certs/ directory. ca_file : \"/etc/ssl/certs/my-company-root.pem\" Finally, we can create the cluster, mounting the CA file in the path we specified in ca_file : k3d cluster create \\ --volume \" ${ HOME } /.k3d/my-registries.yaml:/etc/rancher/k3s/registries.yaml\" \\ --volume \" ${ HOME } /.k3d/my-company-root.pem:/etc/ssl/certs/my-company-root.pem\"","title":"Secure registries"},{"location":"usage/registries/#using-a-local-registry","text":"","title":"Using a local registry"},{"location":"usage/registries/#preface-referencing-local-registries","text":"In the next sections, you\u2019re going to create a local registry (i.e. a container image registry running in a container in your docker host). That container will have a name, e.g. mycluster-registry . If you follow the guide closely (or definitely if you use the k3d-managed option), this name will be known to all the hosts (K3s containers) and workloads in your k3d cluster. However, you usually want to push images into that registry from your local machine, which does not know that name by default. Now you have a few options, including the following three: Use localhost : Since the container will have a port mapped to your local host, you can just directly reference it via e.g. localhost:12345 , where 12345 is the mapped port If you later pull the image from the registry, only the repository path (e.g. myrepo/myimage:mytag in mycluster-registry:5000/myrepo/myimage:mytag ) matters to find your image in the targeted registry. Get your machine to know the container name: For this you can use the plain old hosts file ( /etc/hosts on Unix systems and C:\\windows\\system32\\drivers\\etc\\hosts on Windows) by adding an entry like the following to the end of the file: 127.0.0.1 mycluster-registry Use some special resolving magic: Tools like dnsmasq or nss-myhostname (see info box below) and others can setup your local resolver to directly resolve the registry name to 127.0.0.1 . nss-myhostname to resolve *.localhost Luckily (for Linux users), NSS-myhostname ships with many Linux distributions and should resolve *.localhost automatically to 127.0.0.1 . Otherwise, it\u2019s installable using sudo apt install libnss-myhostname .","title":"Preface: Referencing local registries"},{"location":"usage/registries/#using-k3d-managed-registries","text":"","title":"Using k3d-managed registries"},{"location":"usage/registries/#create-a-dedicated-registry-together-with-your-cluster","text":"k3d cluster create mycluster --registry-create mycluster-registry : This creates your cluster mycluster together with a registry container called mycluster-registry k3d sets everything up in the cluster for containerd to be able to pull images from that registry (using the registries.yaml file) the port, which the registry is listening on will be mapped to a random port on your host system Check the k3d command output or docker ps -f name = mycluster-registry to find the exposed port Test your registry","title":"Create a dedicated registry together with your cluster"},{"location":"usage/registries/#create-a-customized-k3d-managed-registry","text":"k3d registry create myregistry.localhost --port 12345 creates a new registry called k3d-myregistry.localhost (could be used with automatic resolution of *.localhost , see next section - also, note the k3d- prefix that k3d adds to all resources it creates) k3d cluster create newcluster --registry-use k3d-myregistry.localhost:12345 (make sure you use the k3d- prefix here) creates a new cluster set up to use that registry Test your registry","title":"Create a customized k3d-managed registry"},{"location":"usage/registries/#using-your-own-not-k3d-managed-local-registry","text":"We recommend using a k3d-managed registry, as it plays nicely together with k3d clusters, but here\u2019s also a guide to create your own (not k3d-managed) registry, if you need features or customizations, that k3d does not provide: Using your own (not k3d-managed) local registry You can start your own local registry it with some docker commands, like: docker volume create local_registry docker container run -d --name registry.localhost -v local_registry:/var/lib/registry --restart always -p 12345 :5000 registry:2 These commands will start your registry container with name and port (on your host) registry.localhost:12345 . In order to push to this registry, you will need to make it accessible as described in the next section. Once your registry is up and running, we will need to add it to your registries.yaml configuration file. Finally, you have to connect the registry network to the k3d cluster network: docker network connect k3d-k3s-default registry.localhost . And then you can test your local registry .","title":"Using your own (not k3d-managed) local registry"},{"location":"usage/registries/#pushing-to-your-local-registry-address","text":"See Preface The information below has been addressed in the preface for this section .","title":"Pushing to your local registry address"},{"location":"usage/registries/#testing-your-registry","text":"You should test that you can push to your registry from your local development machine. use images from that registry in Deployments in your k3d cluster. We will verify these two things for a local registry (located at k3d-registry.localhost:12345 ) running in your development machine. Things would be basically the same for checking an external registry, but some additional configuration could be necessary in your local machine when using an authenticated or secure registry (please refer to Docker\u2019s documentation for this). Assumptions : In the following test cases, we assume that the registry name k3d-registry.localhost resolves to 127.0.0.1 in your local machine (see section preface for more details ) and to the registry container IP for the k3d cluster nodes (K3s containers). Note : as per the explanation in the preface , you could replace k3d-registry.localhost:12345 with localhost:12345 in the docker tag and docker push commands below (but not in the kubectl part!)","title":"Testing your registry"},{"location":"usage/registries/#nginx-deployment","text":"First, we can download some image (like nginx ) and push it to our local registry with: docker pull nginx:latest docker tag nginx:latest k3d-registry.localhost:12345/nginx:latest docker push k3d-registry.localhost:12345/nginx:latest Then we can deploy a pod referencing this image to your cluster: cat <<EOF | kubectl apply -f - apiVersion: apps/v1 kind: Deployment metadata: name: nginx-test-registry labels: app: nginx-test-registry spec: replicas: 1 selector: matchLabels: app: nginx-test-registry template: metadata: labels: app: nginx-test-registry spec: containers: - name: nginx-test-registry image: k3d-registry.localhost:12345/nginx:latest ports: - containerPort: 80 EOF Then you should check that the pod is running with kubectl get pods -l \"app=nginx-test-registry\" .","title":"Nginx Deployment"},{"location":"usage/registries/#alpine-pod","text":"Pull the alpine image: docker pull alpine:latest re-tag it to reference your newly created registry: docker tag alpine:latest k3d-registry.localhost:12345/testimage:local push it: docker push k3d-registry.localhost:12345/testimage:local Use kubectl to create a new pod in your cluster using that image to see, if the cluster can pull from the new registry: kubectl run --image k3d-registry.localhost:12345/testimage:local testimage --command -- tail -f /dev/null (creates a container that will not do anything but keep on running)","title":"Alpine Pod"},{"location":"usage/registries/#creating-a-registry-proxy-pull-through-registry","text":"Create a pull-through registry k3d registry create docker-io ` # Create a registry named k3d-docker-io` \\ -p 5000 ` # listening on local host port 5000` \\ --proxy-remote-url https://registry-1.docker.io ` # let it mirror the Docker Hub registry` \\ -v ~/.local/share/docker-io-registry:/var/lib/registry ` # also persist the downloaded images on the device outside the container` Create registry.yml mirrors : \"docker.io\" : endpoint : - http://k3d-docker-io:5000 Create a cluster and using the pull-through cache k3d cluster create cluster01 --registry-use k3d-docker-io:5000 --registry-config registry.yml After cluster01 ready, create another cluster with the same registry or rebuild the cluster, it will use the already locally cached images. k3d cluster create cluster02 --registry-use k3d-docker-io:5000 --registry-config registry.yml","title":"Creating a registry proxy / pull-through registry"},{"location":"usage/registries/#creating-a-registry-proxy-pull-through-registry-via-configfile","text":"Create a config file, e.g. /home/me/test-regcache.yaml apiVersion : k3d.io/v1alpha5 kind : Simple metadata : name : test-regcache registries : create : name : docker-io # name of the registry container proxy : remoteURL : https://registry-1.docker.io # proxy DockerHub volumes : - /tmp/reg:/var/lib/registry # persist data locally in /tmp/reg config : | # tell K3s to use this registry when pulling from DockerHub mirrors: \"docker.io\": endpoint: - http://docker-io:5000 Create cluster from config: k3d cluster create -c /home/me/test-regcache.yaml","title":"Creating a registry proxy / pull-through registry via configfile"},{"location":"usage/advanced/calico/","text":"Use Calico instead of Flannel \u00b6 Network Policies k3s comes with a controller that enforces network policies by default. You do not need to switch to Calico for network policies to be enforced. See https://github.com/k3s-io/k3s/issues/1308 for more information. The docs below assume you want to switch to Calico\u2019s policy engine, thus setting --disable-network-policy . 1. Download and modify the Calico descriptor \u00b6 You can following the documentation And then you have to change the ConfigMap calico-config . On the cni_network_config add the entry for allowing IP forwarding \"container_settings\" : { \"allow_ip_forwarding\" : true } Or you can directly use this calico.yaml manifest 2. Create the cluster without flannel and with calico \u00b6 On the k3s cluster creation : add the flags --flannel-backend=none and --disable-network-policy . For this, on k3d you need to forward this flag to k3s with the option --k3s-arg . mount ( --volume ) the calico descriptor in the auto deploy manifest directory of k3s /var/lib/rancher/k3s/server/manifests/ So the command of the cluster creation is (when you are at root of the k3d repository) k3d cluster create \" ${ clustername } \" \\ --k3s-arg '--flannel-backend=none@server:*' \\ --k3s-arg '--disable-network-policy' \\ --volume \" $( pwd ) /docs/usage/guides/calico.yaml:/var/lib/rancher/k3s/server/manifests/calico.yaml\" In this example : change \"${clustername}\" with the name of the cluster (or set a variable). $(pwd)/docs/usage/guides/calico.yaml is the absolute path of the calico manifest, you can adapt it. You can add other options, see . The cluster will start without flannel and with Calico as CNI Plugin. For watching for the pod(s) deployment watch \"kubectl get pods -n kube-system\" You will have something like this at beginning (with the command line kubectl get pods -n kube-system ) NAME READY STATUS RESTARTS AGE helm-install-traefik-pn84f 0 /1 Pending 0 3s calico-node-97rx8 0 /1 Init:0/3 0 3s metrics-server-7566d596c8-hwnqq 0 /1 Pending 0 2s calico-kube-controllers-58b656d69f-2z7cn 0 /1 Pending 0 2s local-path-provisioner-6d59f47c7-rmswg 0 /1 Pending 0 2s coredns-8655855d6-cxtnr 0 /1 Pending 0 2s And when it finish to start NAME READY STATUS RESTARTS AGE metrics-server-7566d596c8-hwnqq 1 /1 Running 0 56s calico-node-97rx8 1 /1 Running 0 57s helm-install-traefik-pn84f 0 /1 Completed 1 57s svclb-traefik-lmjr5 2 /2 Running 0 28s calico-kube-controllers-58b656d69f-2z7cn 1 /1 Running 0 56s local-path-provisioner-6d59f47c7-rmswg 1 /1 Running 0 56s traefik-758cd5fc85-x8p57 1 /1 Running 0 28s coredns-8655855d6-cxtnr 1 /1 Running 0 56s Note : you can use the auto deploy manifest or a kubectl apply depending on your needs Calico is not as quick as Flannel (but it provides more features) References \u00b6 https://rancher.com/docs/k3s/latest/en/installation/network-options/ https://docs.projectcalico.org/getting-started/kubernetes/k3s/","title":"Use Calico instead of Flannel"},{"location":"usage/advanced/calico/#use-calico-instead-of-flannel","text":"Network Policies k3s comes with a controller that enforces network policies by default. You do not need to switch to Calico for network policies to be enforced. See https://github.com/k3s-io/k3s/issues/1308 for more information. The docs below assume you want to switch to Calico\u2019s policy engine, thus setting --disable-network-policy .","title":"Use Calico instead of Flannel"},{"location":"usage/advanced/calico/#1-download-and-modify-the-calico-descriptor","text":"You can following the documentation And then you have to change the ConfigMap calico-config . On the cni_network_config add the entry for allowing IP forwarding \"container_settings\" : { \"allow_ip_forwarding\" : true } Or you can directly use this calico.yaml manifest","title":"1. Download and modify the Calico descriptor"},{"location":"usage/advanced/calico/#2-create-the-cluster-without-flannel-and-with-calico","text":"On the k3s cluster creation : add the flags --flannel-backend=none and --disable-network-policy . For this, on k3d you need to forward this flag to k3s with the option --k3s-arg . mount ( --volume ) the calico descriptor in the auto deploy manifest directory of k3s /var/lib/rancher/k3s/server/manifests/ So the command of the cluster creation is (when you are at root of the k3d repository) k3d cluster create \" ${ clustername } \" \\ --k3s-arg '--flannel-backend=none@server:*' \\ --k3s-arg '--disable-network-policy' \\ --volume \" $( pwd ) /docs/usage/guides/calico.yaml:/var/lib/rancher/k3s/server/manifests/calico.yaml\" In this example : change \"${clustername}\" with the name of the cluster (or set a variable). $(pwd)/docs/usage/guides/calico.yaml is the absolute path of the calico manifest, you can adapt it. You can add other options, see . The cluster will start without flannel and with Calico as CNI Plugin. For watching for the pod(s) deployment watch \"kubectl get pods -n kube-system\" You will have something like this at beginning (with the command line kubectl get pods -n kube-system ) NAME READY STATUS RESTARTS AGE helm-install-traefik-pn84f 0 /1 Pending 0 3s calico-node-97rx8 0 /1 Init:0/3 0 3s metrics-server-7566d596c8-hwnqq 0 /1 Pending 0 2s calico-kube-controllers-58b656d69f-2z7cn 0 /1 Pending 0 2s local-path-provisioner-6d59f47c7-rmswg 0 /1 Pending 0 2s coredns-8655855d6-cxtnr 0 /1 Pending 0 2s And when it finish to start NAME READY STATUS RESTARTS AGE metrics-server-7566d596c8-hwnqq 1 /1 Running 0 56s calico-node-97rx8 1 /1 Running 0 57s helm-install-traefik-pn84f 0 /1 Completed 1 57s svclb-traefik-lmjr5 2 /2 Running 0 28s calico-kube-controllers-58b656d69f-2z7cn 1 /1 Running 0 56s local-path-provisioner-6d59f47c7-rmswg 1 /1 Running 0 56s traefik-758cd5fc85-x8p57 1 /1 Running 0 28s coredns-8655855d6-cxtnr 1 /1 Running 0 56s Note : you can use the auto deploy manifest or a kubectl apply depending on your needs Calico is not as quick as Flannel (but it provides more features)","title":"2. Create the cluster without flannel and with calico"},{"location":"usage/advanced/calico/#references","text":"https://rancher.com/docs/k3s/latest/en/installation/network-options/ https://docs.projectcalico.org/getting-started/kubernetes/k3s/","title":"References"},{"location":"usage/advanced/cuda/","text":"Running CUDA workloads \u00b6 If you want to run CUDA workloads on the K3s container you need to customize the container. CUDA workloads require the NVIDIA Container Runtime, so containerd needs to be configured to use this runtime. The K3s container itself also needs to run with this runtime. If you are using Docker you can install the NVIDIA Container Toolkit . Building a customized K3s image \u00b6 To get the NVIDIA container runtime in the K3s image you need to build your own K3s image. The native K3s image is based on Alpine but the NVIDIA container runtime is not supported on Alpine yet. To get around this we need to build the image with a supported base image. Dockerfile \u00b6 Dockerfile : ARG K3S_TAG = \"v1.21.2-k3s1\" FROM rancher/k3s:$K3S_TAG as k3s FROM nvidia/cuda:11.2.0-base-ubuntu18.04 ARG NVIDIA_CONTAINER_RUNTIME_VERSION ENV NVIDIA_CONTAINER_RUNTIME_VERSION = $NVIDIA_CONTAINER_RUNTIME_VERSION RUN echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections RUN apt-get update && \\ apt-get -y install gnupg2 curl # Install NVIDIA Container Runtime RUN curl -s -L https://nvidia.github.io/nvidia-container-runtime/gpgkey | apt-key add - RUN curl -s -L https://nvidia.github.io/nvidia-container-runtime/ubuntu18.04/nvidia-container-runtime.list | tee /etc/apt/sources.list.d/nvidia-container-runtime.list RUN apt-get update && \\ apt-get -y install nvidia-container-runtime = ${ NVIDIA_CONTAINER_RUNTIME_VERSION } COPY --from = k3s / / RUN mkdir -p /etc && \\ echo 'hosts: files dns' > /etc/nsswitch.conf RUN chmod 1777 /tmp # Provide custom containerd configuration to configure the nvidia-container-runtime RUN mkdir -p /var/lib/rancher/k3s/agent/etc/containerd/ COPY config.toml.tmpl /var/lib/rancher/k3s/agent/etc/containerd/config.toml.tmpl # Deploy the nvidia driver plugin on startup RUN mkdir -p /var/lib/rancher/k3s/server/manifests COPY device-plugin-daemonset.yaml /var/lib/rancher/k3s/server/manifests/nvidia-device-plugin-daemonset.yaml VOLUME /var/lib/kubelet VOLUME /var/lib/rancher/k3s VOLUME /var/lib/cni VOLUME /var/log ENV PATH = \" $PATH :/bin/aux\" ENTRYPOINT [ \"/bin/k3s\" ] CMD [ \"agent\" ] This Dockerfile is based on the K3s Dockerfile The following changes are applied: Change the base images to nvidia/cuda:11.2.0-base-ubuntu18.04 so the NVIDIA Container Runtime can be installed. The version of cuda:xx.x.x must match the one you\u2019re planning to use. Add a custom containerd config.toml template to add the NVIDIA Container Runtime. This replaces the default runc runtime Add a manifest for the NVIDIA driver plugin for Kubernetes Configure containerd \u00b6 We need to configure containerd to use the NVIDIA Container Runtime. We need to customize the config.toml that is used at startup. K3s provides a way to do this using a config.toml.tmpl file. More information can be found on the K3s site . [ plugins . opt ] path = \"{{ .NodeConfig.Containerd.Opt }}\" [ plugins . cri ] stream_server_address = \"127.0.0.1\" stream_server_port = \"10010\" {{ - if . IsRunningInUserNS }} disable_cgroup = true disable_apparmor = true restrict_oom_score_adj = true {{ end }} {{ - if . NodeConfig . AgentConfig . PauseImage }} sandbox_image = \"{{ .NodeConfig.AgentConfig.PauseImage }}\" {{ end }} {{ - if not . NodeConfig . NoFlannel }} [ plugins . cri . cni ] bin_dir = \"{{ .NodeConfig.AgentConfig.CNIBinDir }}\" conf_dir = \"{{ .NodeConfig.AgentConfig.CNIConfDir }}\" {{ end }} [ plugins . cri . containerd . runtimes . runc ] # ---- changed from ' io . containerd . runc . v2 ' for GPU support runtime_type = \"io.containerd.runtime.v1.linux\" # ---- added for GPU support [ plugins . linux ] runtime = \"nvidia-container-runtime\" {{ if . PrivateRegistryConfig }} {{ if . PrivateRegistryConfig . Mirrors }} [ plugins . cri . registry . mirrors ]{{ end }} {{ range $ k , $ v := . PrivateRegistryConfig . Mirrors }} [ plugins . cri . registry . mirrors . \"{{$k}}\" ] endpoint = [{{ range $ i , $ j := $ v . Endpoints }}{{ if $ i }}, {{ end }}{{ printf \"%q\" .}}{{ end }}] {{ end }} {{ range $ k , $ v := . PrivateRegistryConfig . Configs }} {{ if $ v . Auth }} [ plugins . cri . registry . configs . \"{{$k}}\" . auth ] {{ if $ v . Auth . Username }} username = \"{{ $v.Auth.Username }}\" {{ end }} {{ if $ v . Auth . Password }} password = \"{{ $v.Auth.Password }}\" {{ end }} {{ if $ v . Auth . Auth }} auth = \"{{ $v.Auth.Auth }}\" {{ end }} {{ if $ v . Auth . IdentityToken }} identitytoken = \"{{ $v.Auth.IdentityToken }}\" {{ end }} {{ end }} {{ if $ v . TLS }} [ plugins . cri . registry . configs . \"{{$k}}\" . tls ] {{ if $ v . TLS . CAFile }} ca_file = \"{{ $v.TLS.CAFile }}\" {{ end }} {{ if $ v . TLS . CertFile }} cert_file = \"{{ $v.TLS.CertFile }}\" {{ end }} {{ if $ v . TLS . KeyFile }} key_file = \"{{ $v.TLS.KeyFile }}\" {{ end }} {{ end }} {{ end }} {{ end }} The NVIDIA device plugin \u00b6 To enable NVIDIA GPU support on Kubernetes you also need to install the NVIDIA device plugin . The device plugin is a deamonset and allows you to automatically: Expose the number of GPUs on each nodes of your cluster Keep track of the health of your GPUs Run GPU enabled containers in your Kubernetes cluster. apiVersion : apps/v1 kind : DaemonSet metadata : name : nvidia-device-plugin-daemonset namespace : kube-system spec : selector : matchLabels : name : nvidia-device-plugin-ds template : metadata : # Mark this pod as a critical add-on; when enabled, the critical add-on scheduler # reserves resources for critical add-on pods so that they can be rescheduled after # a failure. This annotation works in tandem with the toleration below. annotations : scheduler.alpha.kubernetes.io/critical-pod : \"\" labels : name : nvidia-device-plugin-ds spec : tolerations : # Allow this pod to be rescheduled while the node is in \"critical add-ons only\" mode. # This, along with the annotation above marks this pod as a critical add-on. - key : CriticalAddonsOnly operator : Exists containers : - env : - name : DP_DISABLE_HEALTHCHECKS value : xids image : nvidia/k8s-device-plugin:1.11 name : nvidia-device-plugin-ctr securityContext : allowPrivilegeEscalation : true capabilities : drop : [ \"ALL\" ] volumeMounts : - name : device-plugin mountPath : /var/lib/kubelet/device-plugins volumes : - name : device-plugin hostPath : path : /var/lib/kubelet/device-plugins Build the K3s image \u00b6 To build the custom image we need to build K3s because we need the generated output. Put the following files in a directory: Dockerfile config.toml.tmpl device-plugin-daemonset.yaml build.sh cuda-vector-add.yaml The build.sh script is configured using exports & defaults to v1.21.2+k3s1 . Please set at least the IMAGE_REGISTRY variable! The script performs the following steps builds the custom K3s image including the nvidia drivers. build.sh : #!/bin/bash set -euxo pipefail K3S_TAG = ${ K3S_TAG := \"v1.21.2-k3s1\" } # replace + with -, if needed IMAGE_REGISTRY = ${ IMAGE_REGISTRY := \"MY_REGISTRY\" } IMAGE_REPOSITORY = ${ IMAGE_REPOSITORY := \"rancher/k3s\" } IMAGE_TAG = \" $K3S_TAG -cuda\" IMAGE = ${ IMAGE := \" $IMAGE_REGISTRY / $IMAGE_REPOSITORY : $IMAGE_TAG \" } NVIDIA_CONTAINER_RUNTIME_VERSION = ${ NVIDIA_CONTAINER_RUNTIME_VERSION := \"3.5.0-1\" } echo \"IMAGE= $IMAGE \" # due to some unknown reason, copying symlinks fails with buildkit enabled DOCKER_BUILDKIT = 0 docker build \\ --build-arg K3S_TAG = $K3S_TAG \\ --build-arg NVIDIA_CONTAINER_RUNTIME_VERSION = $NVIDIA_CONTAINER_RUNTIME_VERSION \\ -t $IMAGE . docker push $IMAGE echo \"Done!\" Run and test the custom image with k3d \u00b6 You can use the image with k3d: k3d cluster create gputest --image = $IMAGE --gpus = 1 Deploy a test pod : kubectl apply -f cuda-vector-add.yaml kubectl logs cuda-vector-add This should output something like the following: $ kubectl logs cuda-vector-add [ Vector addition of 50000 elements ] Copy input data from the host memory to the CUDA device CUDA kernel launch with 196 blocks of 256 threads Copy output data from the CUDA device to the host memory Test PASSED Done If the cuda-vector-add pod is stuck in Pending state, probably the device-driver daemonset didn\u2019t get deployed correctly from the auto-deploy manifests. In that case, you can apply it manually via kubectl apply -f device-plugin-daemonset.yaml . Known issues \u00b6 This approach does not work on WSL2 yet. The NVIDIA driver plugin and container runtime rely on the NVIDIA Management Library (NVML) which is not yet supported. See the CUDA on WSL User Guide . Acknowledgements \u00b6 Most of the information in this article was obtained from various sources: Add NVIDIA GPU support to k3s with containerd microk8s K3s k3s-gpu Authors \u00b6 @markrexwinkel @vainkop @iwilltry42","title":"Running CUDA workloads"},{"location":"usage/advanced/cuda/#running-cuda-workloads","text":"If you want to run CUDA workloads on the K3s container you need to customize the container. CUDA workloads require the NVIDIA Container Runtime, so containerd needs to be configured to use this runtime. The K3s container itself also needs to run with this runtime. If you are using Docker you can install the NVIDIA Container Toolkit .","title":"Running CUDA workloads"},{"location":"usage/advanced/cuda/#building-a-customized-k3s-image","text":"To get the NVIDIA container runtime in the K3s image you need to build your own K3s image. The native K3s image is based on Alpine but the NVIDIA container runtime is not supported on Alpine yet. To get around this we need to build the image with a supported base image.","title":"Building a customized K3s image"},{"location":"usage/advanced/cuda/#dockerfile","text":"Dockerfile : ARG K3S_TAG = \"v1.21.2-k3s1\" FROM rancher/k3s:$K3S_TAG as k3s FROM nvidia/cuda:11.2.0-base-ubuntu18.04 ARG NVIDIA_CONTAINER_RUNTIME_VERSION ENV NVIDIA_CONTAINER_RUNTIME_VERSION = $NVIDIA_CONTAINER_RUNTIME_VERSION RUN echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections RUN apt-get update && \\ apt-get -y install gnupg2 curl # Install NVIDIA Container Runtime RUN curl -s -L https://nvidia.github.io/nvidia-container-runtime/gpgkey | apt-key add - RUN curl -s -L https://nvidia.github.io/nvidia-container-runtime/ubuntu18.04/nvidia-container-runtime.list | tee /etc/apt/sources.list.d/nvidia-container-runtime.list RUN apt-get update && \\ apt-get -y install nvidia-container-runtime = ${ NVIDIA_CONTAINER_RUNTIME_VERSION } COPY --from = k3s / / RUN mkdir -p /etc && \\ echo 'hosts: files dns' > /etc/nsswitch.conf RUN chmod 1777 /tmp # Provide custom containerd configuration to configure the nvidia-container-runtime RUN mkdir -p /var/lib/rancher/k3s/agent/etc/containerd/ COPY config.toml.tmpl /var/lib/rancher/k3s/agent/etc/containerd/config.toml.tmpl # Deploy the nvidia driver plugin on startup RUN mkdir -p /var/lib/rancher/k3s/server/manifests COPY device-plugin-daemonset.yaml /var/lib/rancher/k3s/server/manifests/nvidia-device-plugin-daemonset.yaml VOLUME /var/lib/kubelet VOLUME /var/lib/rancher/k3s VOLUME /var/lib/cni VOLUME /var/log ENV PATH = \" $PATH :/bin/aux\" ENTRYPOINT [ \"/bin/k3s\" ] CMD [ \"agent\" ] This Dockerfile is based on the K3s Dockerfile The following changes are applied: Change the base images to nvidia/cuda:11.2.0-base-ubuntu18.04 so the NVIDIA Container Runtime can be installed. The version of cuda:xx.x.x must match the one you\u2019re planning to use. Add a custom containerd config.toml template to add the NVIDIA Container Runtime. This replaces the default runc runtime Add a manifest for the NVIDIA driver plugin for Kubernetes","title":"Dockerfile"},{"location":"usage/advanced/cuda/#configure-containerd","text":"We need to configure containerd to use the NVIDIA Container Runtime. We need to customize the config.toml that is used at startup. K3s provides a way to do this using a config.toml.tmpl file. More information can be found on the K3s site . [ plugins . opt ] path = \"{{ .NodeConfig.Containerd.Opt }}\" [ plugins . cri ] stream_server_address = \"127.0.0.1\" stream_server_port = \"10010\" {{ - if . IsRunningInUserNS }} disable_cgroup = true disable_apparmor = true restrict_oom_score_adj = true {{ end }} {{ - if . NodeConfig . AgentConfig . PauseImage }} sandbox_image = \"{{ .NodeConfig.AgentConfig.PauseImage }}\" {{ end }} {{ - if not . NodeConfig . NoFlannel }} [ plugins . cri . cni ] bin_dir = \"{{ .NodeConfig.AgentConfig.CNIBinDir }}\" conf_dir = \"{{ .NodeConfig.AgentConfig.CNIConfDir }}\" {{ end }} [ plugins . cri . containerd . runtimes . runc ] # ---- changed from ' io . containerd . runc . v2 ' for GPU support runtime_type = \"io.containerd.runtime.v1.linux\" # ---- added for GPU support [ plugins . linux ] runtime = \"nvidia-container-runtime\" {{ if . PrivateRegistryConfig }} {{ if . PrivateRegistryConfig . Mirrors }} [ plugins . cri . registry . mirrors ]{{ end }} {{ range $ k , $ v := . PrivateRegistryConfig . Mirrors }} [ plugins . cri . registry . mirrors . \"{{$k}}\" ] endpoint = [{{ range $ i , $ j := $ v . Endpoints }}{{ if $ i }}, {{ end }}{{ printf \"%q\" .}}{{ end }}] {{ end }} {{ range $ k , $ v := . PrivateRegistryConfig . Configs }} {{ if $ v . Auth }} [ plugins . cri . registry . configs . \"{{$k}}\" . auth ] {{ if $ v . Auth . Username }} username = \"{{ $v.Auth.Username }}\" {{ end }} {{ if $ v . Auth . Password }} password = \"{{ $v.Auth.Password }}\" {{ end }} {{ if $ v . Auth . Auth }} auth = \"{{ $v.Auth.Auth }}\" {{ end }} {{ if $ v . Auth . IdentityToken }} identitytoken = \"{{ $v.Auth.IdentityToken }}\" {{ end }} {{ end }} {{ if $ v . TLS }} [ plugins . cri . registry . configs . \"{{$k}}\" . tls ] {{ if $ v . TLS . CAFile }} ca_file = \"{{ $v.TLS.CAFile }}\" {{ end }} {{ if $ v . TLS . CertFile }} cert_file = \"{{ $v.TLS.CertFile }}\" {{ end }} {{ if $ v . TLS . KeyFile }} key_file = \"{{ $v.TLS.KeyFile }}\" {{ end }} {{ end }} {{ end }} {{ end }}","title":"Configure containerd"},{"location":"usage/advanced/cuda/#the-nvidia-device-plugin","text":"To enable NVIDIA GPU support on Kubernetes you also need to install the NVIDIA device plugin . The device plugin is a deamonset and allows you to automatically: Expose the number of GPUs on each nodes of your cluster Keep track of the health of your GPUs Run GPU enabled containers in your Kubernetes cluster. apiVersion : apps/v1 kind : DaemonSet metadata : name : nvidia-device-plugin-daemonset namespace : kube-system spec : selector : matchLabels : name : nvidia-device-plugin-ds template : metadata : # Mark this pod as a critical add-on; when enabled, the critical add-on scheduler # reserves resources for critical add-on pods so that they can be rescheduled after # a failure. This annotation works in tandem with the toleration below. annotations : scheduler.alpha.kubernetes.io/critical-pod : \"\" labels : name : nvidia-device-plugin-ds spec : tolerations : # Allow this pod to be rescheduled while the node is in \"critical add-ons only\" mode. # This, along with the annotation above marks this pod as a critical add-on. - key : CriticalAddonsOnly operator : Exists containers : - env : - name : DP_DISABLE_HEALTHCHECKS value : xids image : nvidia/k8s-device-plugin:1.11 name : nvidia-device-plugin-ctr securityContext : allowPrivilegeEscalation : true capabilities : drop : [ \"ALL\" ] volumeMounts : - name : device-plugin mountPath : /var/lib/kubelet/device-plugins volumes : - name : device-plugin hostPath : path : /var/lib/kubelet/device-plugins","title":"The NVIDIA device plugin"},{"location":"usage/advanced/cuda/#build-the-k3s-image","text":"To build the custom image we need to build K3s because we need the generated output. Put the following files in a directory: Dockerfile config.toml.tmpl device-plugin-daemonset.yaml build.sh cuda-vector-add.yaml The build.sh script is configured using exports & defaults to v1.21.2+k3s1 . Please set at least the IMAGE_REGISTRY variable! The script performs the following steps builds the custom K3s image including the nvidia drivers. build.sh : #!/bin/bash set -euxo pipefail K3S_TAG = ${ K3S_TAG := \"v1.21.2-k3s1\" } # replace + with -, if needed IMAGE_REGISTRY = ${ IMAGE_REGISTRY := \"MY_REGISTRY\" } IMAGE_REPOSITORY = ${ IMAGE_REPOSITORY := \"rancher/k3s\" } IMAGE_TAG = \" $K3S_TAG -cuda\" IMAGE = ${ IMAGE := \" $IMAGE_REGISTRY / $IMAGE_REPOSITORY : $IMAGE_TAG \" } NVIDIA_CONTAINER_RUNTIME_VERSION = ${ NVIDIA_CONTAINER_RUNTIME_VERSION := \"3.5.0-1\" } echo \"IMAGE= $IMAGE \" # due to some unknown reason, copying symlinks fails with buildkit enabled DOCKER_BUILDKIT = 0 docker build \\ --build-arg K3S_TAG = $K3S_TAG \\ --build-arg NVIDIA_CONTAINER_RUNTIME_VERSION = $NVIDIA_CONTAINER_RUNTIME_VERSION \\ -t $IMAGE . docker push $IMAGE echo \"Done!\"","title":"Build the K3s image"},{"location":"usage/advanced/cuda/#run-and-test-the-custom-image-with-k3d","text":"You can use the image with k3d: k3d cluster create gputest --image = $IMAGE --gpus = 1 Deploy a test pod : kubectl apply -f cuda-vector-add.yaml kubectl logs cuda-vector-add This should output something like the following: $ kubectl logs cuda-vector-add [ Vector addition of 50000 elements ] Copy input data from the host memory to the CUDA device CUDA kernel launch with 196 blocks of 256 threads Copy output data from the CUDA device to the host memory Test PASSED Done If the cuda-vector-add pod is stuck in Pending state, probably the device-driver daemonset didn\u2019t get deployed correctly from the auto-deploy manifests. In that case, you can apply it manually via kubectl apply -f device-plugin-daemonset.yaml .","title":"Run and test the custom image with k3d"},{"location":"usage/advanced/cuda/#known-issues","text":"This approach does not work on WSL2 yet. The NVIDIA driver plugin and container runtime rely on the NVIDIA Management Library (NVML) which is not yet supported. See the CUDA on WSL User Guide .","title":"Known issues"},{"location":"usage/advanced/cuda/#acknowledgements","text":"Most of the information in this article was obtained from various sources: Add NVIDIA GPU support to k3s with containerd microk8s K3s k3s-gpu","title":"Acknowledgements"},{"location":"usage/advanced/cuda/#authors","text":"@markrexwinkel @vainkop @iwilltry42","title":"Authors"},{"location":"usage/advanced/podman/","text":"Using Podman instead of Docker \u00b6 Podman has an Docker API compatibility layer . k3d uses the Docker API and is compatible with Podman v4 and higher. Podman support is experimental k3d is not guaranteed to work with Podman. If you find a bug, do help by filing an issue Tested with podman version: Client: Podman Engine Version: 4 .3.1 API Version: 4 .3.1 Using Podman \u00b6 Ensure the Podman system socket is available: sudo systemctl enable --now podman.socket # or to start the socket daemonless # sudo podman system service --time=0 & Disable timeout for podman service: See the podman-system-service (1) man page for more information. mkdir -p /etc/containers/containers.conf.d echo 'service_timeout=0' > /etc/containers/containers.conf.d/timeout.conf To point k3d at the right Docker socket, create a symbolic link: sudo ln -s /run/podman/podman.sock /var/run/docker.sock # or install your system podman-docker if available sudo k3d cluster create Alternatively, set DOCKER_HOST when running k3d: export DOCKER_HOST = unix:///run/podman/podman.sock export DOCKER_SOCK = /run/podman/podman.sock sudo --preserve-env = DOCKER_HOST --preserve-env = DOCKER_SOCK k3d cluster create Using rootless Podman \u00b6 Ensure the Podman user socket is available: systemctl --user enable --now podman.socket # or podman system service --time=0 & Set DOCKER_HOST when running k3d: XDG_RUNTIME_DIR = ${ XDG_RUNTIME_DIR :- /run/user/ $( id -u ) } export DOCKER_HOST = unix:// $XDG_RUNTIME_DIR /podman/podman.sock export DOCKER_SOCK = $XDG_RUNTIME_DIR /podman/podman.sock k3d cluster create Using cgroup (v2) \u00b6 By default, a non-root user can only get memory controller and pids controller to be delegated. To run properly we need to enable CPU, CPUSET, and I/O delegation Make sure you\u2019re running cgroup v2 If /sys/fs/cgroup/cgroup.controllers is present on your system, you are using v2, otherwise you are using v1. mkdir -p /etc/systemd/system/user@.service.d cat > /etc/systemd/system/user@.service.d/delegate.conf <<EOF [Service] Delegate=cpu cpuset io memory pids EOF systemctl daemon-reload Reference: https://rootlesscontaine.rs/getting-started/common/cgroup2/#enabling-cpu-cpuset-and-io-delegation Using remote Podman \u00b6 Start Podman on the remote host , and then set DOCKER_HOST when running k3d: export DOCKER_HOST=ssh://username@hostname export DOCKER_SOCK=/run/user/1000/podman/podman.sock k3d cluster create macOS \u00b6 Initialize a podman machine if not done already podman machine init Or start an already existing podman machine podman machine start Grab connection details podman system connection ls Name URI Identity Default podman-machine-default ssh://core@localhost:53685/run/user/501/podman/podman.sock /Users/myusername/.ssh/podman-machine-default true podman-machine-default-root ssh://root@localhost:53685/run/podman/podman.sock /Users/myusername/.ssh/podman-machine-default false Edit your OpenSSH config file to specify the IdentityFile vim ~/.ssh/config Host localhost IdentityFile /Users/myusername/.ssh/podman-machine-default Rootless mode \u00b6 Delegate the cpuset cgroup controller to the user\u2019s systemd slice, export the docker environment variables referenced above for the non-root connection, and create the cluster: podman machine ssh bash -e <<EOF printf '[Service]\\nDelegate=cpuset\\n' | sudo tee /etc/systemd/system/user@.service.d/k3d.conf sudo systemctl daemon-reload sudo systemctl restart \"user@\\${UID}\" EOF export DOCKER_HOST = ssh://core@localhost:53685 export DOCKER_SOCKET = /run/user/501/podman/podman.sock k3d cluster create --k3s-arg '--kubelet-arg=feature-gates=KubeletInUserNamespace=true@server:*' Rootful mode \u00b6 Export the docker environment variables referenced above for the root connection and create the cluster: export DOCKER_HOST = ssh://root@localhost:53685 export DOCKER_SOCK = /run/podman/podman.sock k3d cluster create Podman network \u00b6 The default podman network has dns disabled. To allow k3d cluster nodes to communicate with dns a new network must be created. podman network create k3d podman network inspect k3d -f '{{ .DNSEnabled }}' true Creating local registries \u00b6 Because Podman does not have a default \u201cbridge\u201d network, you have to specify a network using the --default-network flag when creating a local registry: k3d registry create --default-network podman mycluster-registry To use this registry with a cluster, pass the --registry-use flag: k3d cluster create --registry-use mycluster-registry mycluster Incompatibility with --registry-create Because --registry-create assumes the default network to be \u201cbridge\u201d, avoid --registry-create when using Podman. Instead, always create a registry before creating a cluster. Missing cpuset cgroup controller If you experince an error regarding missing cpuset cgroup controller, ensure the user unit xdg-document-portal.service is disabled by running systemctl --user stop xdg-document-portal.service . See this issue","title":"Using Podman instead of Docker"},{"location":"usage/advanced/podman/#using-podman-instead-of-docker","text":"Podman has an Docker API compatibility layer . k3d uses the Docker API and is compatible with Podman v4 and higher. Podman support is experimental k3d is not guaranteed to work with Podman. If you find a bug, do help by filing an issue Tested with podman version: Client: Podman Engine Version: 4 .3.1 API Version: 4 .3.1","title":"Using Podman instead of Docker"},{"location":"usage/advanced/podman/#using-podman","text":"Ensure the Podman system socket is available: sudo systemctl enable --now podman.socket # or to start the socket daemonless # sudo podman system service --time=0 & Disable timeout for podman service: See the podman-system-service (1) man page for more information. mkdir -p /etc/containers/containers.conf.d echo 'service_timeout=0' > /etc/containers/containers.conf.d/timeout.conf To point k3d at the right Docker socket, create a symbolic link: sudo ln -s /run/podman/podman.sock /var/run/docker.sock # or install your system podman-docker if available sudo k3d cluster create Alternatively, set DOCKER_HOST when running k3d: export DOCKER_HOST = unix:///run/podman/podman.sock export DOCKER_SOCK = /run/podman/podman.sock sudo --preserve-env = DOCKER_HOST --preserve-env = DOCKER_SOCK k3d cluster create","title":"Using Podman"},{"location":"usage/advanced/podman/#using-rootless-podman","text":"Ensure the Podman user socket is available: systemctl --user enable --now podman.socket # or podman system service --time=0 & Set DOCKER_HOST when running k3d: XDG_RUNTIME_DIR = ${ XDG_RUNTIME_DIR :- /run/user/ $( id -u ) } export DOCKER_HOST = unix:// $XDG_RUNTIME_DIR /podman/podman.sock export DOCKER_SOCK = $XDG_RUNTIME_DIR /podman/podman.sock k3d cluster create","title":"Using rootless Podman"},{"location":"usage/advanced/podman/#using-cgroup-v2","text":"By default, a non-root user can only get memory controller and pids controller to be delegated. To run properly we need to enable CPU, CPUSET, and I/O delegation Make sure you\u2019re running cgroup v2 If /sys/fs/cgroup/cgroup.controllers is present on your system, you are using v2, otherwise you are using v1. mkdir -p /etc/systemd/system/user@.service.d cat > /etc/systemd/system/user@.service.d/delegate.conf <<EOF [Service] Delegate=cpu cpuset io memory pids EOF systemctl daemon-reload Reference: https://rootlesscontaine.rs/getting-started/common/cgroup2/#enabling-cpu-cpuset-and-io-delegation","title":"Using cgroup (v2)"},{"location":"usage/advanced/podman/#using-remote-podman","text":"Start Podman on the remote host , and then set DOCKER_HOST when running k3d: export DOCKER_HOST=ssh://username@hostname export DOCKER_SOCK=/run/user/1000/podman/podman.sock k3d cluster create","title":"Using remote Podman"},{"location":"usage/advanced/podman/#macos","text":"Initialize a podman machine if not done already podman machine init Or start an already existing podman machine podman machine start Grab connection details podman system connection ls Name URI Identity Default podman-machine-default ssh://core@localhost:53685/run/user/501/podman/podman.sock /Users/myusername/.ssh/podman-machine-default true podman-machine-default-root ssh://root@localhost:53685/run/podman/podman.sock /Users/myusername/.ssh/podman-machine-default false Edit your OpenSSH config file to specify the IdentityFile vim ~/.ssh/config Host localhost IdentityFile /Users/myusername/.ssh/podman-machine-default","title":"macOS"},{"location":"usage/advanced/podman/#rootless-mode","text":"Delegate the cpuset cgroup controller to the user\u2019s systemd slice, export the docker environment variables referenced above for the non-root connection, and create the cluster: podman machine ssh bash -e <<EOF printf '[Service]\\nDelegate=cpuset\\n' | sudo tee /etc/systemd/system/user@.service.d/k3d.conf sudo systemctl daemon-reload sudo systemctl restart \"user@\\${UID}\" EOF export DOCKER_HOST = ssh://core@localhost:53685 export DOCKER_SOCKET = /run/user/501/podman/podman.sock k3d cluster create --k3s-arg '--kubelet-arg=feature-gates=KubeletInUserNamespace=true@server:*'","title":"Rootless mode"},{"location":"usage/advanced/podman/#rootful-mode","text":"Export the docker environment variables referenced above for the root connection and create the cluster: export DOCKER_HOST = ssh://root@localhost:53685 export DOCKER_SOCK = /run/podman/podman.sock k3d cluster create","title":"Rootful mode"},{"location":"usage/advanced/podman/#podman-network","text":"The default podman network has dns disabled. To allow k3d cluster nodes to communicate with dns a new network must be created. podman network create k3d podman network inspect k3d -f '{{ .DNSEnabled }}' true","title":"Podman network"},{"location":"usage/advanced/podman/#creating-local-registries","text":"Because Podman does not have a default \u201cbridge\u201d network, you have to specify a network using the --default-network flag when creating a local registry: k3d registry create --default-network podman mycluster-registry To use this registry with a cluster, pass the --registry-use flag: k3d cluster create --registry-use mycluster-registry mycluster Incompatibility with --registry-create Because --registry-create assumes the default network to be \u201cbridge\u201d, avoid --registry-create when using Podman. Instead, always create a registry before creating a cluster. Missing cpuset cgroup controller If you experince an error regarding missing cpuset cgroup controller, ensure the user unit xdg-document-portal.service is disabled by running systemctl --user stop xdg-document-portal.service . See this issue","title":"Creating local registries"},{"location":"usage/commands/k3d/","text":"k3d \u00b6 https://k3d.io/ -> Run k3s in Docker! Synopsis \u00b6 https://k3d.io/ k3d is a wrapper CLI that helps you to easily create k3s clusters inside docker. Nodes of a k3d cluster are docker containers running a k3s image. All Nodes of a k3d cluster are part of the same docker network. k3d [flags] Options \u00b6 -h, --help help for k3d --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) --version Show k3d and default k3s version SEE ALSO \u00b6 k3d cluster - Manage cluster(s) k3d completion - Generate completion scripts for [bash, zsh, fish, powershell | psh] k3d config - Work with config file(s) k3d image - Handle container images. k3d kubeconfig - Manage kubeconfig(s) k3d node - Manage node(s) k3d registry - Manage registry/registries k3d version - Show k3d and default k3s version","title":"K3d"},{"location":"usage/commands/k3d/#k3d","text":"https://k3d.io/ -> Run k3s in Docker!","title":"k3d"},{"location":"usage/commands/k3d/#synopsis","text":"https://k3d.io/ k3d is a wrapper CLI that helps you to easily create k3s clusters inside docker. Nodes of a k3d cluster are docker containers running a k3s image. All Nodes of a k3d cluster are part of the same docker network. k3d [flags]","title":"Synopsis"},{"location":"usage/commands/k3d/#options","text":"-h, --help help for k3d --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) --version Show k3d and default k3s version","title":"Options"},{"location":"usage/commands/k3d/#see-also","text":"k3d cluster - Manage cluster(s) k3d completion - Generate completion scripts for [bash, zsh, fish, powershell | psh] k3d config - Work with config file(s) k3d image - Handle container images. k3d kubeconfig - Manage kubeconfig(s) k3d node - Manage node(s) k3d registry - Manage registry/registries k3d version - Show k3d and default k3s version","title":"SEE ALSO"},{"location":"usage/commands/k3d_cluster/","text":"k3d cluster \u00b6 Manage cluster(s) Synopsis \u00b6 Manage cluster(s) k3d cluster [flags] Options \u00b6 -h, --help help for cluster Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d - https://k3d.io/ -> Run k3s in Docker! k3d cluster create - Create a new cluster k3d cluster delete - Delete cluster(s). k3d cluster edit - [EXPERIMENTAL] Edit cluster(s). k3d cluster list - List cluster(s) k3d cluster start - Start existing k3d cluster(s) k3d cluster stop - Stop existing k3d cluster(s)","title":"K3d cluster"},{"location":"usage/commands/k3d_cluster/#k3d-cluster","text":"Manage cluster(s)","title":"k3d cluster"},{"location":"usage/commands/k3d_cluster/#synopsis","text":"Manage cluster(s) k3d cluster [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_cluster/#options","text":"-h, --help help for cluster","title":"Options"},{"location":"usage/commands/k3d_cluster/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_cluster/#see-also","text":"k3d - https://k3d.io/ -> Run k3s in Docker! k3d cluster create - Create a new cluster k3d cluster delete - Delete cluster(s). k3d cluster edit - [EXPERIMENTAL] Edit cluster(s). k3d cluster list - List cluster(s) k3d cluster start - Start existing k3d cluster(s) k3d cluster stop - Stop existing k3d cluster(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_cluster_create/","text":"k3d cluster create \u00b6 Create a new cluster Synopsis \u00b6 Create a new k3s cluster with containerized nodes (k3s in docker). Every cluster will consist of one or more containers: 1 (or more) server node container (k3s) (optionally) 1 loadbalancer container as the entrypoint to the cluster (nginx) (optionally) 1 (or more) agent node containers (k3s) k3d cluster create NAME [flags] Options \u00b6 -a, --agents int Specify how many agents you want to create --agents-memory string Memory limit imposed on the agents nodes [From docker] --api-port [HOST:]HOSTPORT Specify the Kubernetes API server port exposed on the LoadBalancer (Format: [HOST:]HOSTPORT) - Example: `k3d cluster create --servers 3 --api-port 0.0.0.0:6550` -c, --config string Path of a config file to use -e, --env KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] Add environment variables to nodes (Format: KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] - Example: `k3d cluster create --agents 2 -e \"HTTP_PROXY=my.proxy.com@server:0\" -e \"SOME_KEY=SOME_VAL@server:0\"` --gpus string GPU devices to add to the cluster node containers ('all' to pass all GPUs) [From docker] -h, --help help for create --host-alias ip:host[,host,...] Add ip:host[,host,...] mappings --host-pid-mode Enable host pid mode of server(s) and agent(s) -i, --image string Specify k3s image that you want to use for the nodes --k3s-arg ARG@NODEFILTER[;@NODEFILTER] Additional args passed to k3s command (Format: ARG@NODEFILTER[;@NODEFILTER]) - Example: `k3d cluster create --k3s-arg \"--disable=traefik@server:0\"` --k3s-node-label KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] Add label to k3s node (Format: KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] - Example: `k3d cluster create --agents 2 --k3s-node-label \"my.label@agent:0,1\" --k3s-node-label \"other.label=somevalue@server:0\"` --kubeconfig-switch-context Directly switch the default kubeconfig's current-context to the new cluster's context (requires --kubeconfig-update-default) (default true) --kubeconfig-update-default Directly update the default kubeconfig with the new cluster's context (default true) --lb-config-override strings Use dotted YAML path syntax to override nginx loadbalancer settings --network string Join an existing network --no-image-volume Disable the creation of a volume for importing images --no-lb Disable the creation of a LoadBalancer in front of the server nodes --no-rollback Disable the automatic rollback actions, if anything goes wrong -p, --port [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER] Map ports from the node containers (via the serverlb) to the host (Format: [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER]) - Example: `k3d cluster create --agents 2 -p 8080:80@agent:0 -p 8081@agent:1` --registry-config string Specify path to an extra registries.yaml file --registry-create NAME[:HOST][:HOSTPORT] Create a k3d-managed registry and connect it to the cluster (Format: NAME[:HOST][:HOSTPORT] - Example: `k3d cluster create --registry-create mycluster-registry:0.0.0.0:5432` --registry-use stringArray Connect to one or more k3d-managed registries running locally --runtime-label KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] Add label to container runtime (Format: KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] - Example: `k3d cluster create --agents 2 --runtime-label \"my.label@agent:0,1\" --runtime-label \"other.label=somevalue@server:0\"` --runtime-ulimit NAME[=SOFT]:[HARD] Add ulimit to container runtime (Format: NAME[=SOFT]:[HARD] - Example: `k3d cluster create --agents 2 --runtime-ulimit \"nofile=1024:1024\" --runtime-ulimit \"noproc=1024:1024\"` -s, --servers int Specify how many servers you want to create --servers-memory string Memory limit imposed on the server nodes [From docker] --subnet 172.28.0.0/16 [Experimental: IPAM] Define a subnet for the newly created container network (Example: 172.28.0.0/16) --timeout duration Rollback changes if cluster couldn't be created in specified duration. --token string Specify a cluster token. By default, we generate one. -v, --volume [SOURCE:]DEST[@NODEFILTER[;NODEFILTER...]] Mount volumes into the nodes (Format: [SOURCE:]DEST[@NODEFILTER[;NODEFILTER...]] - Example: `k3d cluster create --agents 2 -v /my/path@agent:0,1 -v /tmp/test:/tmp/other@server:0` --wait Wait for the server(s) to be ready before returning. Use '--timeout DURATION' to not wait forever. (default true) Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d cluster - Manage cluster(s)","title":"K3d cluster create"},{"location":"usage/commands/k3d_cluster_create/#k3d-cluster-create","text":"Create a new cluster","title":"k3d cluster create"},{"location":"usage/commands/k3d_cluster_create/#synopsis","text":"Create a new k3s cluster with containerized nodes (k3s in docker). Every cluster will consist of one or more containers: 1 (or more) server node container (k3s) (optionally) 1 loadbalancer container as the entrypoint to the cluster (nginx) (optionally) 1 (or more) agent node containers (k3s) k3d cluster create NAME [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_cluster_create/#options","text":"-a, --agents int Specify how many agents you want to create --agents-memory string Memory limit imposed on the agents nodes [From docker] --api-port [HOST:]HOSTPORT Specify the Kubernetes API server port exposed on the LoadBalancer (Format: [HOST:]HOSTPORT) - Example: `k3d cluster create --servers 3 --api-port 0.0.0.0:6550` -c, --config string Path of a config file to use -e, --env KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] Add environment variables to nodes (Format: KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] - Example: `k3d cluster create --agents 2 -e \"HTTP_PROXY=my.proxy.com@server:0\" -e \"SOME_KEY=SOME_VAL@server:0\"` --gpus string GPU devices to add to the cluster node containers ('all' to pass all GPUs) [From docker] -h, --help help for create --host-alias ip:host[,host,...] Add ip:host[,host,...] mappings --host-pid-mode Enable host pid mode of server(s) and agent(s) -i, --image string Specify k3s image that you want to use for the nodes --k3s-arg ARG@NODEFILTER[;@NODEFILTER] Additional args passed to k3s command (Format: ARG@NODEFILTER[;@NODEFILTER]) - Example: `k3d cluster create --k3s-arg \"--disable=traefik@server:0\"` --k3s-node-label KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] Add label to k3s node (Format: KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] - Example: `k3d cluster create --agents 2 --k3s-node-label \"my.label@agent:0,1\" --k3s-node-label \"other.label=somevalue@server:0\"` --kubeconfig-switch-context Directly switch the default kubeconfig's current-context to the new cluster's context (requires --kubeconfig-update-default) (default true) --kubeconfig-update-default Directly update the default kubeconfig with the new cluster's context (default true) --lb-config-override strings Use dotted YAML path syntax to override nginx loadbalancer settings --network string Join an existing network --no-image-volume Disable the creation of a volume for importing images --no-lb Disable the creation of a LoadBalancer in front of the server nodes --no-rollback Disable the automatic rollback actions, if anything goes wrong -p, --port [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER] Map ports from the node containers (via the serverlb) to the host (Format: [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER]) - Example: `k3d cluster create --agents 2 -p 8080:80@agent:0 -p 8081@agent:1` --registry-config string Specify path to an extra registries.yaml file --registry-create NAME[:HOST][:HOSTPORT] Create a k3d-managed registry and connect it to the cluster (Format: NAME[:HOST][:HOSTPORT] - Example: `k3d cluster create --registry-create mycluster-registry:0.0.0.0:5432` --registry-use stringArray Connect to one or more k3d-managed registries running locally --runtime-label KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] Add label to container runtime (Format: KEY[=VALUE][@NODEFILTER[;NODEFILTER...]] - Example: `k3d cluster create --agents 2 --runtime-label \"my.label@agent:0,1\" --runtime-label \"other.label=somevalue@server:0\"` --runtime-ulimit NAME[=SOFT]:[HARD] Add ulimit to container runtime (Format: NAME[=SOFT]:[HARD] - Example: `k3d cluster create --agents 2 --runtime-ulimit \"nofile=1024:1024\" --runtime-ulimit \"noproc=1024:1024\"` -s, --servers int Specify how many servers you want to create --servers-memory string Memory limit imposed on the server nodes [From docker] --subnet 172.28.0.0/16 [Experimental: IPAM] Define a subnet for the newly created container network (Example: 172.28.0.0/16) --timeout duration Rollback changes if cluster couldn't be created in specified duration. --token string Specify a cluster token. By default, we generate one. -v, --volume [SOURCE:]DEST[@NODEFILTER[;NODEFILTER...]] Mount volumes into the nodes (Format: [SOURCE:]DEST[@NODEFILTER[;NODEFILTER...]] - Example: `k3d cluster create --agents 2 -v /my/path@agent:0,1 -v /tmp/test:/tmp/other@server:0` --wait Wait for the server(s) to be ready before returning. Use '--timeout DURATION' to not wait forever. (default true)","title":"Options"},{"location":"usage/commands/k3d_cluster_create/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_cluster_create/#see-also","text":"k3d cluster - Manage cluster(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_cluster_delete/","text":"k3d cluster delete \u00b6 Delete cluster(s). Synopsis \u00b6 Delete cluster(s). k3d cluster delete [NAME [NAME ...] | --all] [flags] Options \u00b6 -a, --all Delete all existing clusters -c, --config string Path of a config file to use -h, --help help for delete Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d cluster - Manage cluster(s)","title":"K3d cluster delete"},{"location":"usage/commands/k3d_cluster_delete/#k3d-cluster-delete","text":"Delete cluster(s).","title":"k3d cluster delete"},{"location":"usage/commands/k3d_cluster_delete/#synopsis","text":"Delete cluster(s). k3d cluster delete [NAME [NAME ...] | --all] [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_cluster_delete/#options","text":"-a, --all Delete all existing clusters -c, --config string Path of a config file to use -h, --help help for delete","title":"Options"},{"location":"usage/commands/k3d_cluster_delete/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_cluster_delete/#see-also","text":"k3d cluster - Manage cluster(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_cluster_edit/","text":"k3d cluster edit \u00b6 [EXPERIMENTAL] Edit cluster(s). Synopsis \u00b6 [EXPERIMENTAL] Edit cluster(s). k3d cluster edit CLUSTER [flags] Options \u00b6 -h, --help help for edit --port-add [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER] [EXPERIMENTAL] Map ports from the node containers (via the serverlb) to the host (Format: [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER]) - Example: `k3d node edit k3d-mycluster-serverlb --port-add 8080:80` Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d cluster - Manage cluster(s)","title":"K3d cluster edit"},{"location":"usage/commands/k3d_cluster_edit/#k3d-cluster-edit","text":"[EXPERIMENTAL] Edit cluster(s).","title":"k3d cluster edit"},{"location":"usage/commands/k3d_cluster_edit/#synopsis","text":"[EXPERIMENTAL] Edit cluster(s). k3d cluster edit CLUSTER [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_cluster_edit/#options","text":"-h, --help help for edit --port-add [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER] [EXPERIMENTAL] Map ports from the node containers (via the serverlb) to the host (Format: [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER]) - Example: `k3d node edit k3d-mycluster-serverlb --port-add 8080:80`","title":"Options"},{"location":"usage/commands/k3d_cluster_edit/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_cluster_edit/#see-also","text":"k3d cluster - Manage cluster(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_cluster_list/","text":"k3d cluster list \u00b6 List cluster(s) Synopsis \u00b6 List cluster(s). k3d cluster list [NAME [NAME...]] [flags] Options \u00b6 -h, --help help for list --no-headers Disable headers -o, --output string Output format. One of: json|yaml --token Print k3s cluster token Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d cluster - Manage cluster(s)","title":"K3d cluster list"},{"location":"usage/commands/k3d_cluster_list/#k3d-cluster-list","text":"List cluster(s)","title":"k3d cluster list"},{"location":"usage/commands/k3d_cluster_list/#synopsis","text":"List cluster(s). k3d cluster list [NAME [NAME...]] [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_cluster_list/#options","text":"-h, --help help for list --no-headers Disable headers -o, --output string Output format. One of: json|yaml --token Print k3s cluster token","title":"Options"},{"location":"usage/commands/k3d_cluster_list/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_cluster_list/#see-also","text":"k3d cluster - Manage cluster(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_cluster_start/","text":"k3d cluster start \u00b6 Start existing k3d cluster(s) Synopsis \u00b6 Start existing k3d cluster(s) k3d cluster start [NAME [NAME...] | --all] [flags] Options \u00b6 -a, --all Start all existing clusters -h, --help help for start --timeout duration Maximum waiting time for '--wait' before canceling/returning. --wait Wait for the server(s) (and loadbalancer) to be ready before returning. (default true) Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d cluster - Manage cluster(s)","title":"K3d cluster start"},{"location":"usage/commands/k3d_cluster_start/#k3d-cluster-start","text":"Start existing k3d cluster(s)","title":"k3d cluster start"},{"location":"usage/commands/k3d_cluster_start/#synopsis","text":"Start existing k3d cluster(s) k3d cluster start [NAME [NAME...] | --all] [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_cluster_start/#options","text":"-a, --all Start all existing clusters -h, --help help for start --timeout duration Maximum waiting time for '--wait' before canceling/returning. --wait Wait for the server(s) (and loadbalancer) to be ready before returning. (default true)","title":"Options"},{"location":"usage/commands/k3d_cluster_start/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_cluster_start/#see-also","text":"k3d cluster - Manage cluster(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_cluster_stop/","text":"k3d cluster stop \u00b6 Stop existing k3d cluster(s) Synopsis \u00b6 Stop existing k3d cluster(s). k3d cluster stop [NAME [NAME...] | --all] [flags] Options \u00b6 -a, --all Stop all existing clusters -h, --help help for stop Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d cluster - Manage cluster(s)","title":"K3d cluster stop"},{"location":"usage/commands/k3d_cluster_stop/#k3d-cluster-stop","text":"Stop existing k3d cluster(s)","title":"k3d cluster stop"},{"location":"usage/commands/k3d_cluster_stop/#synopsis","text":"Stop existing k3d cluster(s). k3d cluster stop [NAME [NAME...] | --all] [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_cluster_stop/#options","text":"-a, --all Stop all existing clusters -h, --help help for stop","title":"Options"},{"location":"usage/commands/k3d_cluster_stop/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_cluster_stop/#see-also","text":"k3d cluster - Manage cluster(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_completion/","text":"k3d completion \u00b6 Generate completion scripts for [bash, zsh, fish, powershell | psh] Synopsis \u00b6 To load completions: Bash: $ source <(k3d completion bash) # To load completions for each session, execute once: # Linux: $ k3d completion bash > /etc/bash_completion.d/k3d # macOS: $ k3d completion bash > /usr/local/etc/bash_completion.d/k3d Zsh: # If shell completion is not already enabled in your environment, # you will need to enable it. You can execute the following once: $ echo \"autoload -U compinit; compinit\" >> ~/.zshrc # To load completions for each session, execute once: $ k3d completion zsh > \"${fpath[1]}/_k3d\" # You will need to start a new shell for this setup to take effect. fish: $ k3d completion fish | source # To load completions for each session, execute once: $ k3d completion fish > ~/.config/fish/completions/k3d.fish PowerShell: PS> k3d completion powershell | Out-String | Invoke-Expression # To load completions for every new session, run: PS> k3d completion powershell > k3d.ps1 # and source this file from your PowerShell profile. k3d completion SHELL Options \u00b6 -h, --help help for completion Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d - https://k3d.io/ -> Run k3s in Docker!","title":"K3d completion"},{"location":"usage/commands/k3d_completion/#k3d-completion","text":"Generate completion scripts for [bash, zsh, fish, powershell | psh]","title":"k3d completion"},{"location":"usage/commands/k3d_completion/#synopsis","text":"To load completions: Bash: $ source <(k3d completion bash) # To load completions for each session, execute once: # Linux: $ k3d completion bash > /etc/bash_completion.d/k3d # macOS: $ k3d completion bash > /usr/local/etc/bash_completion.d/k3d Zsh: # If shell completion is not already enabled in your environment, # you will need to enable it. You can execute the following once: $ echo \"autoload -U compinit; compinit\" >> ~/.zshrc # To load completions for each session, execute once: $ k3d completion zsh > \"${fpath[1]}/_k3d\" # You will need to start a new shell for this setup to take effect. fish: $ k3d completion fish | source # To load completions for each session, execute once: $ k3d completion fish > ~/.config/fish/completions/k3d.fish PowerShell: PS> k3d completion powershell | Out-String | Invoke-Expression # To load completions for every new session, run: PS> k3d completion powershell > k3d.ps1 # and source this file from your PowerShell profile. k3d completion SHELL","title":"Synopsis"},{"location":"usage/commands/k3d_completion/#options","text":"-h, --help help for completion","title":"Options"},{"location":"usage/commands/k3d_completion/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_completion/#see-also","text":"k3d - https://k3d.io/ -> Run k3s in Docker!","title":"SEE ALSO"},{"location":"usage/commands/k3d_config/","text":"k3d config \u00b6 Work with config file(s) Synopsis \u00b6 Work with config file(s) k3d config [flags] Options \u00b6 -h, --help help for config Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d - https://k3d.io/ -> Run k3s in Docker! k3d config init - k3d config migrate -","title":"K3d config"},{"location":"usage/commands/k3d_config/#k3d-config","text":"Work with config file(s)","title":"k3d config"},{"location":"usage/commands/k3d_config/#synopsis","text":"Work with config file(s) k3d config [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_config/#options","text":"-h, --help help for config","title":"Options"},{"location":"usage/commands/k3d_config/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_config/#see-also","text":"k3d - https://k3d.io/ -> Run k3s in Docker! k3d config init - k3d config migrate -","title":"SEE ALSO"},{"location":"usage/commands/k3d_config_init/","text":"k3d config init \u00b6 k3d config init [flags] Options \u00b6 -f, --force Force overwrite of target file -h, --help help for init -o, --output string Write a default k3d config (default \"k3d-default.yaml\") Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d config - Work with config file(s)","title":"K3d config init"},{"location":"usage/commands/k3d_config_init/#k3d-config-init","text":"k3d config init [flags]","title":"k3d config init"},{"location":"usage/commands/k3d_config_init/#options","text":"-f, --force Force overwrite of target file -h, --help help for init -o, --output string Write a default k3d config (default \"k3d-default.yaml\")","title":"Options"},{"location":"usage/commands/k3d_config_init/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_config_init/#see-also","text":"k3d config - Work with config file(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_config_migrate/","text":"k3d config migrate \u00b6 k3d config migrate INPUT [OUTPUT] [flags] Options \u00b6 -h, --help help for migrate Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d config - Work with config file(s)","title":"K3d config migrate"},{"location":"usage/commands/k3d_config_migrate/#k3d-config-migrate","text":"k3d config migrate INPUT [OUTPUT] [flags]","title":"k3d config migrate"},{"location":"usage/commands/k3d_config_migrate/#options","text":"-h, --help help for migrate","title":"Options"},{"location":"usage/commands/k3d_config_migrate/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_config_migrate/#see-also","text":"k3d config - Work with config file(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_image/","text":"k3d image \u00b6 Handle container images. Synopsis \u00b6 Handle container images. k3d image [flags] Options \u00b6 -h, --help help for image Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d - https://k3d.io/ -> Run k3s in Docker! k3d image import - Import image(s) from docker into k3d cluster(s).","title":"K3d image"},{"location":"usage/commands/k3d_image/#k3d-image","text":"Handle container images.","title":"k3d image"},{"location":"usage/commands/k3d_image/#synopsis","text":"Handle container images. k3d image [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_image/#options","text":"-h, --help help for image","title":"Options"},{"location":"usage/commands/k3d_image/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_image/#see-also","text":"k3d - https://k3d.io/ -> Run k3s in Docker! k3d image import - Import image(s) from docker into k3d cluster(s).","title":"SEE ALSO"},{"location":"usage/commands/k3d_image_import/","text":"k3d image import \u00b6 Import image(s) from docker into k3d cluster(s). Synopsis \u00b6 Import image(s) from docker into k3d cluster(s). If an IMAGE starts with the prefix \u2018docker.io/\u2019, then this prefix is stripped internally. That is, \u2018docker.io/k3d-io/k3d-tools:latest\u2019 is treated as \u2018k3d-io/k3d-tools:latest\u2019. If an IMAGE starts with the prefix \u2018library/\u2019 (or \u2018docker.io/library/\u2019), then this prefix is stripped internally. That is, \u2018library/busybox:latest\u2019 (or \u2018docker.io/library/busybox:latest\u2019) are treated as \u2018busybox:latest\u2019. If an IMAGE does not have a version tag, then \u2018:latest\u2019 is assumed. That is, \u2018k3d-io/k3d-tools\u2019 is treated as \u2018k3d-io/k3d-tools:latest\u2019. A file ARCHIVE always takes precedence. So if a file \u2018./k3d-io/k3d-tools\u2019 exists, k3d will try to import it instead of the IMAGE of the same name. k3d image import [IMAGE | ARCHIVE [IMAGE | ARCHIVE...]] [flags] Options \u00b6 -c, --cluster stringArray Select clusters to load the image to. (default [k3s-default]) -h, --help help for import -k, --keep-tarball Do not delete the tarball containing the saved images from the shared volume -t, --keep-tools Do not delete the tools node after import -m, --mode string Which method to use to import images into the cluster [auto, direct, tools]. See https://k3d.io/usage/guides/importing_images/ (default \"tools-node\") Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d image - Handle container images.","title":"K3d image import"},{"location":"usage/commands/k3d_image_import/#k3d-image-import","text":"Import image(s) from docker into k3d cluster(s).","title":"k3d image import"},{"location":"usage/commands/k3d_image_import/#synopsis","text":"Import image(s) from docker into k3d cluster(s). If an IMAGE starts with the prefix \u2018docker.io/\u2019, then this prefix is stripped internally. That is, \u2018docker.io/k3d-io/k3d-tools:latest\u2019 is treated as \u2018k3d-io/k3d-tools:latest\u2019. If an IMAGE starts with the prefix \u2018library/\u2019 (or \u2018docker.io/library/\u2019), then this prefix is stripped internally. That is, \u2018library/busybox:latest\u2019 (or \u2018docker.io/library/busybox:latest\u2019) are treated as \u2018busybox:latest\u2019. If an IMAGE does not have a version tag, then \u2018:latest\u2019 is assumed. That is, \u2018k3d-io/k3d-tools\u2019 is treated as \u2018k3d-io/k3d-tools:latest\u2019. A file ARCHIVE always takes precedence. So if a file \u2018./k3d-io/k3d-tools\u2019 exists, k3d will try to import it instead of the IMAGE of the same name. k3d image import [IMAGE | ARCHIVE [IMAGE | ARCHIVE...]] [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_image_import/#options","text":"-c, --cluster stringArray Select clusters to load the image to. (default [k3s-default]) -h, --help help for import -k, --keep-tarball Do not delete the tarball containing the saved images from the shared volume -t, --keep-tools Do not delete the tools node after import -m, --mode string Which method to use to import images into the cluster [auto, direct, tools]. See https://k3d.io/usage/guides/importing_images/ (default \"tools-node\")","title":"Options"},{"location":"usage/commands/k3d_image_import/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_image_import/#see-also","text":"k3d image - Handle container images.","title":"SEE ALSO"},{"location":"usage/commands/k3d_kubeconfig/","text":"k3d kubeconfig \u00b6 Manage kubeconfig(s) Synopsis \u00b6 Manage kubeconfig(s) k3d kubeconfig [flags] Options \u00b6 -h, --help help for kubeconfig Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d - https://k3d.io/ -> Run k3s in Docker! k3d kubeconfig get - Print kubeconfig(s) from cluster(s). k3d kubeconfig merge - Write/Merge kubeconfig(s) from cluster(s) into new or existing kubeconfig/file.","title":"K3d kubeconfig"},{"location":"usage/commands/k3d_kubeconfig/#k3d-kubeconfig","text":"Manage kubeconfig(s)","title":"k3d kubeconfig"},{"location":"usage/commands/k3d_kubeconfig/#synopsis","text":"Manage kubeconfig(s) k3d kubeconfig [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_kubeconfig/#options","text":"-h, --help help for kubeconfig","title":"Options"},{"location":"usage/commands/k3d_kubeconfig/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_kubeconfig/#see-also","text":"k3d - https://k3d.io/ -> Run k3s in Docker! k3d kubeconfig get - Print kubeconfig(s) from cluster(s). k3d kubeconfig merge - Write/Merge kubeconfig(s) from cluster(s) into new or existing kubeconfig/file.","title":"SEE ALSO"},{"location":"usage/commands/k3d_kubeconfig_get/","text":"k3d kubeconfig get \u00b6 Print kubeconfig(s) from cluster(s). Synopsis \u00b6 Print kubeconfig(s) from cluster(s). k3d kubeconfig get [CLUSTER [CLUSTER [...]] | --all] [flags] Options \u00b6 -a, --all Output kubeconfigs from all existing clusters -h, --help help for get Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d kubeconfig - Manage kubeconfig(s)","title":"K3d kubeconfig get"},{"location":"usage/commands/k3d_kubeconfig_get/#k3d-kubeconfig-get","text":"Print kubeconfig(s) from cluster(s).","title":"k3d kubeconfig get"},{"location":"usage/commands/k3d_kubeconfig_get/#synopsis","text":"Print kubeconfig(s) from cluster(s). k3d kubeconfig get [CLUSTER [CLUSTER [...]] | --all] [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_kubeconfig_get/#options","text":"-a, --all Output kubeconfigs from all existing clusters -h, --help help for get","title":"Options"},{"location":"usage/commands/k3d_kubeconfig_get/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_kubeconfig_get/#see-also","text":"k3d kubeconfig - Manage kubeconfig(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_kubeconfig_merge/","text":"k3d kubeconfig merge \u00b6 Write/Merge kubeconfig(s) from cluster(s) into new or existing kubeconfig/file. Synopsis \u00b6 Write/Merge kubeconfig(s) from cluster(s) into new or existing kubeconfig/file. k3d kubeconfig merge [CLUSTER [CLUSTER [...]] | --all] [flags] Options \u00b6 -a, --all Get kubeconfigs from all existing clusters -h, --help help for merge -d, --kubeconfig-merge-default Merge into the default kubeconfig ($KUBECONFIG or /home/thklein/.kube/config) -s, --kubeconfig-switch-context Switch to new context (default true) -o, --output string Define output [ - | FILE ] (default from $KUBECONFIG or /home/thklein/.kube/config --overwrite [Careful!] Overwrite existing file, ignoring its contents -u, --update Update conflicting fields in existing kubeconfig (default true) Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d kubeconfig - Manage kubeconfig(s)","title":"K3d kubeconfig merge"},{"location":"usage/commands/k3d_kubeconfig_merge/#k3d-kubeconfig-merge","text":"Write/Merge kubeconfig(s) from cluster(s) into new or existing kubeconfig/file.","title":"k3d kubeconfig merge"},{"location":"usage/commands/k3d_kubeconfig_merge/#synopsis","text":"Write/Merge kubeconfig(s) from cluster(s) into new or existing kubeconfig/file. k3d kubeconfig merge [CLUSTER [CLUSTER [...]] | --all] [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_kubeconfig_merge/#options","text":"-a, --all Get kubeconfigs from all existing clusters -h, --help help for merge -d, --kubeconfig-merge-default Merge into the default kubeconfig ($KUBECONFIG or /home/thklein/.kube/config) -s, --kubeconfig-switch-context Switch to new context (default true) -o, --output string Define output [ - | FILE ] (default from $KUBECONFIG or /home/thklein/.kube/config --overwrite [Careful!] Overwrite existing file, ignoring its contents -u, --update Update conflicting fields in existing kubeconfig (default true)","title":"Options"},{"location":"usage/commands/k3d_kubeconfig_merge/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_kubeconfig_merge/#see-also","text":"k3d kubeconfig - Manage kubeconfig(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_node/","text":"k3d node \u00b6 Manage node(s) Synopsis \u00b6 Manage node(s) k3d node [flags] Options \u00b6 -h, --help help for node Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d - https://k3d.io/ -> Run k3s in Docker! k3d node create - Create a new k3s node in docker k3d node delete - Delete node(s). k3d node edit - [EXPERIMENTAL] Edit node(s). k3d node list - List node(s) k3d node start - Start an existing k3d node k3d node stop - Stop an existing k3d node","title":"K3d node"},{"location":"usage/commands/k3d_node/#k3d-node","text":"Manage node(s)","title":"k3d node"},{"location":"usage/commands/k3d_node/#synopsis","text":"Manage node(s) k3d node [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_node/#options","text":"-h, --help help for node","title":"Options"},{"location":"usage/commands/k3d_node/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_node/#see-also","text":"k3d - https://k3d.io/ -> Run k3s in Docker! k3d node create - Create a new k3s node in docker k3d node delete - Delete node(s). k3d node edit - [EXPERIMENTAL] Edit node(s). k3d node list - List node(s) k3d node start - Start an existing k3d node k3d node stop - Stop an existing k3d node","title":"SEE ALSO"},{"location":"usage/commands/k3d_node_create/","text":"k3d node create \u00b6 Create a new k3s node in docker Synopsis \u00b6 Create a new containerized k3s node (k3s in docker). k3d node create NAME [flags] Options \u00b6 -c, --cluster string Cluster URL or k3d cluster name to connect to. (default \"k3s-default\") -h, --help help for create -i, --image string Specify k3s image used for the node(s) (default: copied from existing node) --k3s-arg stringArray Additional args passed to k3d command --k3s-node-label strings Specify k3s node labels in format \"foo=bar\" --memory string Memory limit imposed on the node [From docker] -n, --network strings Add node to (another) runtime network --replicas int Number of replicas of this node specification. (default 1) --role string Specify node role [server, agent] (default \"agent\") --runtime-label strings Specify container runtime labels in format \"foo=bar\" --runtime-ulimit strings Specify container runtime ulimit in format \"ulimit=soft:hard\" --timeout duration Maximum waiting time for '--wait' before canceling/returning. -t, --token string Override cluster token (required when connecting to an external cluster) --wait Wait for the node(s) to be ready before returning. (default true) Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d node - Manage node(s)","title":"K3d node create"},{"location":"usage/commands/k3d_node_create/#k3d-node-create","text":"Create a new k3s node in docker","title":"k3d node create"},{"location":"usage/commands/k3d_node_create/#synopsis","text":"Create a new containerized k3s node (k3s in docker). k3d node create NAME [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_node_create/#options","text":"-c, --cluster string Cluster URL or k3d cluster name to connect to. (default \"k3s-default\") -h, --help help for create -i, --image string Specify k3s image used for the node(s) (default: copied from existing node) --k3s-arg stringArray Additional args passed to k3d command --k3s-node-label strings Specify k3s node labels in format \"foo=bar\" --memory string Memory limit imposed on the node [From docker] -n, --network strings Add node to (another) runtime network --replicas int Number of replicas of this node specification. (default 1) --role string Specify node role [server, agent] (default \"agent\") --runtime-label strings Specify container runtime labels in format \"foo=bar\" --runtime-ulimit strings Specify container runtime ulimit in format \"ulimit=soft:hard\" --timeout duration Maximum waiting time for '--wait' before canceling/returning. -t, --token string Override cluster token (required when connecting to an external cluster) --wait Wait for the node(s) to be ready before returning. (default true)","title":"Options"},{"location":"usage/commands/k3d_node_create/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_node_create/#see-also","text":"k3d node - Manage node(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_node_delete/","text":"k3d node delete \u00b6 Delete node(s). Synopsis \u00b6 Delete node(s). k3d node delete (NAME | --all) [flags] Options \u00b6 -a, --all Delete all existing nodes -h, --help help for delete -r, --registries Also delete registries Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d node - Manage node(s)","title":"K3d node delete"},{"location":"usage/commands/k3d_node_delete/#k3d-node-delete","text":"Delete node(s).","title":"k3d node delete"},{"location":"usage/commands/k3d_node_delete/#synopsis","text":"Delete node(s). k3d node delete (NAME | --all) [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_node_delete/#options","text":"-a, --all Delete all existing nodes -h, --help help for delete -r, --registries Also delete registries","title":"Options"},{"location":"usage/commands/k3d_node_delete/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_node_delete/#see-also","text":"k3d node - Manage node(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_node_edit/","text":"k3d node edit \u00b6 [EXPERIMENTAL] Edit node(s). Synopsis \u00b6 [EXPERIMENTAL] Edit node(s). k3d node edit NODE [flags] Options \u00b6 -h, --help help for edit --port-add [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER] [EXPERIMENTAL] (serverlb only!) Map ports from the node container to the host (Format: [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER]) - Example: `k3d node edit k3d-mycluster-serverlb --port-add 8080:80` Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d node - Manage node(s)","title":"K3d node edit"},{"location":"usage/commands/k3d_node_edit/#k3d-node-edit","text":"[EXPERIMENTAL] Edit node(s).","title":"k3d node edit"},{"location":"usage/commands/k3d_node_edit/#synopsis","text":"[EXPERIMENTAL] Edit node(s). k3d node edit NODE [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_node_edit/#options","text":"-h, --help help for edit --port-add [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER] [EXPERIMENTAL] (serverlb only!) Map ports from the node container to the host (Format: [HOST:][HOSTPORT:]CONTAINERPORT[/PROTOCOL][@NODEFILTER]) - Example: `k3d node edit k3d-mycluster-serverlb --port-add 8080:80`","title":"Options"},{"location":"usage/commands/k3d_node_edit/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_node_edit/#see-also","text":"k3d node - Manage node(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_node_list/","text":"k3d node list \u00b6 List node(s) Synopsis \u00b6 List node(s). k3d node list [NODE [NODE...]] [flags] Options \u00b6 -h, --help help for list --no-headers Disable headers -o, --output string Output format. One of: json|yaml Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d node - Manage node(s)","title":"K3d node list"},{"location":"usage/commands/k3d_node_list/#k3d-node-list","text":"List node(s)","title":"k3d node list"},{"location":"usage/commands/k3d_node_list/#synopsis","text":"List node(s). k3d node list [NODE [NODE...]] [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_node_list/#options","text":"-h, --help help for list --no-headers Disable headers -o, --output string Output format. One of: json|yaml","title":"Options"},{"location":"usage/commands/k3d_node_list/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_node_list/#see-also","text":"k3d node - Manage node(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_node_start/","text":"k3d node start \u00b6 Start an existing k3d node Synopsis \u00b6 Start an existing k3d node. k3d node start NODE [flags] Options \u00b6 -h, --help help for start Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d node - Manage node(s)","title":"K3d node start"},{"location":"usage/commands/k3d_node_start/#k3d-node-start","text":"Start an existing k3d node","title":"k3d node start"},{"location":"usage/commands/k3d_node_start/#synopsis","text":"Start an existing k3d node. k3d node start NODE [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_node_start/#options","text":"-h, --help help for start","title":"Options"},{"location":"usage/commands/k3d_node_start/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_node_start/#see-also","text":"k3d node - Manage node(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_node_stop/","text":"k3d node stop \u00b6 Stop an existing k3d node Synopsis \u00b6 Stop an existing k3d node. k3d node stop NAME [flags] Options \u00b6 -h, --help help for stop Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d node - Manage node(s)","title":"K3d node stop"},{"location":"usage/commands/k3d_node_stop/#k3d-node-stop","text":"Stop an existing k3d node","title":"k3d node stop"},{"location":"usage/commands/k3d_node_stop/#synopsis","text":"Stop an existing k3d node. k3d node stop NAME [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_node_stop/#options","text":"-h, --help help for stop","title":"Options"},{"location":"usage/commands/k3d_node_stop/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_node_stop/#see-also","text":"k3d node - Manage node(s)","title":"SEE ALSO"},{"location":"usage/commands/k3d_registry/","text":"k3d registry \u00b6 Manage registry/registries Synopsis \u00b6 Manage registry/registries k3d registry [flags] Options \u00b6 -h, --help help for registry Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d - https://k3d.io/ -> Run k3s in Docker! k3d registry create - Create a new registry k3d registry delete - Delete registry/registries. k3d registry list - List registries","title":"K3d registry"},{"location":"usage/commands/k3d_registry/#k3d-registry","text":"Manage registry/registries","title":"k3d registry"},{"location":"usage/commands/k3d_registry/#synopsis","text":"Manage registry/registries k3d registry [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_registry/#options","text":"-h, --help help for registry","title":"Options"},{"location":"usage/commands/k3d_registry/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_registry/#see-also","text":"k3d - https://k3d.io/ -> Run k3s in Docker! k3d registry create - Create a new registry k3d registry delete - Delete registry/registries. k3d registry list - List registries","title":"SEE ALSO"},{"location":"usage/commands/k3d_registry_create/","text":"k3d registry create \u00b6 Create a new registry Synopsis \u00b6 Create a new registry. k3d registry create NAME [flags] Options \u00b6 --default-network string Specify the network connected to the registry (default \"bridge\") -h, --help help for create -i, --image string Specify image used for the registry (default \"docker.io/library/registry:2\") --no-help Disable the help text (How-To use the registry) -p, --port [HOST:]HOSTPORT Select which port the registry should be listening on on your machine (localhost) (Format: [HOST:]HOSTPORT) - Example: `k3d registry create --port 0.0.0.0:5111` (default \"random\") --proxy-password string Specify the password of the proxied remote registry --proxy-remote-url string Specify the url of the proxied remote registry --proxy-username string Specify the username of the proxied remote registry -v, --volume [SOURCE:]DEST Mount volumes into the registry node (Format: [SOURCE:]DEST Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d registry - Manage registry/registries","title":"K3d registry create"},{"location":"usage/commands/k3d_registry_create/#k3d-registry-create","text":"Create a new registry","title":"k3d registry create"},{"location":"usage/commands/k3d_registry_create/#synopsis","text":"Create a new registry. k3d registry create NAME [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_registry_create/#options","text":"--default-network string Specify the network connected to the registry (default \"bridge\") -h, --help help for create -i, --image string Specify image used for the registry (default \"docker.io/library/registry:2\") --no-help Disable the help text (How-To use the registry) -p, --port [HOST:]HOSTPORT Select which port the registry should be listening on on your machine (localhost) (Format: [HOST:]HOSTPORT) - Example: `k3d registry create --port 0.0.0.0:5111` (default \"random\") --proxy-password string Specify the password of the proxied remote registry --proxy-remote-url string Specify the url of the proxied remote registry --proxy-username string Specify the username of the proxied remote registry -v, --volume [SOURCE:]DEST Mount volumes into the registry node (Format: [SOURCE:]DEST","title":"Options"},{"location":"usage/commands/k3d_registry_create/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_registry_create/#see-also","text":"k3d registry - Manage registry/registries","title":"SEE ALSO"},{"location":"usage/commands/k3d_registry_delete/","text":"k3d registry delete \u00b6 Delete registry/registries. Synopsis \u00b6 Delete registry/registries. k3d registry delete (NAME | --all) [flags] Options \u00b6 -a, --all Delete all existing registries -h, --help help for delete Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d registry - Manage registry/registries","title":"K3d registry delete"},{"location":"usage/commands/k3d_registry_delete/#k3d-registry-delete","text":"Delete registry/registries.","title":"k3d registry delete"},{"location":"usage/commands/k3d_registry_delete/#synopsis","text":"Delete registry/registries. k3d registry delete (NAME | --all) [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_registry_delete/#options","text":"-a, --all Delete all existing registries -h, --help help for delete","title":"Options"},{"location":"usage/commands/k3d_registry_delete/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_registry_delete/#see-also","text":"k3d registry - Manage registry/registries","title":"SEE ALSO"},{"location":"usage/commands/k3d_registry_list/","text":"k3d registry list \u00b6 List registries Synopsis \u00b6 List registries. k3d registry list [NAME [NAME...]] [flags] Options \u00b6 -h, --help help for list --no-headers Disable headers -o, --output string Output format. One of: json|yaml Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d registry - Manage registry/registries","title":"K3d registry list"},{"location":"usage/commands/k3d_registry_list/#k3d-registry-list","text":"List registries","title":"k3d registry list"},{"location":"usage/commands/k3d_registry_list/#synopsis","text":"List registries. k3d registry list [NAME [NAME...]] [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_registry_list/#options","text":"-h, --help help for list --no-headers Disable headers -o, --output string Output format. One of: json|yaml","title":"Options"},{"location":"usage/commands/k3d_registry_list/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_registry_list/#see-also","text":"k3d registry - Manage registry/registries","title":"SEE ALSO"},{"location":"usage/commands/k3d_version/","text":"k3d version \u00b6 Show k3d and default k3s version Synopsis \u00b6 Show k3d and default k3s version k3d version [flags] Options \u00b6 -h, --help help for version -o, --output string This will return version information as a different format. Only json is supported Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d - https://k3d.io/ -> Run k3s in Docker! k3d version list - List k3d/K3s versions. Component can be one of \u2018k3d\u2019, \u2018k3s\u2019, \u2018k3d-proxy\u2019, \u2018k3d-tools\u2019.","title":"K3d version"},{"location":"usage/commands/k3d_version/#k3d-version","text":"Show k3d and default k3s version","title":"k3d version"},{"location":"usage/commands/k3d_version/#synopsis","text":"Show k3d and default k3s version k3d version [flags]","title":"Synopsis"},{"location":"usage/commands/k3d_version/#options","text":"-h, --help help for version -o, --output string This will return version information as a different format. Only json is supported","title":"Options"},{"location":"usage/commands/k3d_version/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_version/#see-also","text":"k3d - https://k3d.io/ -> Run k3s in Docker! k3d version list - List k3d/K3s versions. Component can be one of \u2018k3d\u2019, \u2018k3s\u2019, \u2018k3d-proxy\u2019, \u2018k3d-tools\u2019.","title":"SEE ALSO"},{"location":"usage/commands/k3d_version_list/","text":"k3d version list \u00b6 List k3d/K3s versions. Component can be one of \u2018k3d\u2019, \u2018k3s\u2019, \u2018k3d-proxy\u2019, \u2018k3d-tools\u2019. k3d version list COMPONENT [flags] Options \u00b6 -e, --exclude string Exclude Regexp (default excludes pre-releases and arch-specific tags) (default \".+(rc|engine|alpha|beta|dev|test|arm|arm64|amd64).*\") -f, --format string [DEPRECATED] Use --output instead (default \"raw\") -h, --help help for list -i, --include string Include Regexp (default includes everything (default \".*\") -l, --limit int Limit number of tags in output (0 = unlimited) -o, --output string Output Format [raw | repo] (default \"raw\") -s, --sort string Sort Mode (asc | desc | off) (default \"desc\") Options inherited from parent commands \u00b6 --timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging) SEE ALSO \u00b6 k3d version - Show k3d and default k3s version","title":"K3d version list"},{"location":"usage/commands/k3d_version_list/#k3d-version-list","text":"List k3d/K3s versions. Component can be one of \u2018k3d\u2019, \u2018k3s\u2019, \u2018k3d-proxy\u2019, \u2018k3d-tools\u2019. k3d version list COMPONENT [flags]","title":"k3d version list"},{"location":"usage/commands/k3d_version_list/#options","text":"-e, --exclude string Exclude Regexp (default excludes pre-releases and arch-specific tags) (default \".+(rc|engine|alpha|beta|dev|test|arm|arm64|amd64).*\") -f, --format string [DEPRECATED] Use --output instead (default \"raw\") -h, --help help for list -i, --include string Include Regexp (default includes everything (default \".*\") -l, --limit int Limit number of tags in output (0 = unlimited) -o, --output string Output Format [raw | repo] (default \"raw\") -s, --sort string Sort Mode (asc | desc | off) (default \"desc\")","title":"Options"},{"location":"usage/commands/k3d_version_list/#options-inherited-from-parent-commands","text":"--timestamps Enable Log timestamps --trace Enable super verbose output (trace logging) --verbose Enable verbose output (debug logging)","title":"Options inherited from parent commands"},{"location":"usage/commands/k3d_version_list/#see-also","text":"k3d version - Show k3d and default k3s version","title":"SEE ALSO"}]}